<?php

namespace Drupal\commerce_epn\Plugin\Commerce\PaymentGateway;

use Drupal\commerce_payment\CreditCard;
use Drupal\commerce_payment\Entity\PaymentInterface;
use Drupal\commerce_payment\Entity\PaymentMethodInterface;
use Drupal\commerce_payment\Exception\DeclineException;
use Drupal\commerce_payment\Exception\InvalidRequestException;
use Drupal\commerce_payment\Exception\InvalidResponseException;
use Drupal\commerce_payment\PaymentMethodTypeManager;
use Drupal\commerce_payment\PaymentTypeManager;
use Drupal\commerce_payment\Plugin\Commerce\PaymentGateway\OnsitePaymentGatewayBase;
use Drupal\commerce_price\Price;
use Drupal\Component\Datetime\TimeInterface;
use Drupal\Core\Entity\EntityTypeManagerInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\facets\Exception\Exception;
use GuzzleHttp\Client;
use Symfony\Component\DependencyInjection\ContainerInterface;


define('UC_EPN_HOST', 'https://www.eprocessingnetwork.com');
define('UC_EPN_TRANSPATH', '/cgi-bin/tdbe/transact.pl');
define('UC_EPN_RECURPATH', '/cgi-bin/tdbe/recur.pl');

/**
 * @CommercePaymentGateway(
 *   id = "epn_payment_gateway",
 *   label = @Translation("eProcessingNetwork gateway."),
 *   display_label = @Translation("EPN Gateway."),
 *   forms = {},
 *   js_library = "string",
 *   payment_method_types = {"credit_card"},
 *   credit_card_types = {
 *     "amex", "dinersclub", "discover", "mastercard", "visa",
 *   },
 * )
 */
class EpnPaymentGateway extends OnsitePaymentGatewayBase implements EpnPaymentGatewayInterface {

  /**
   * @var Client
   */
  protected $client;

  /**
   * EpnPaymentGateway constructor.
   *
   * @param array $configuration
   * @param string $plugin_id
   * @param mixed $plugin_definition
   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
   * @param \Drupal\commerce_payment\PaymentTypeManager $payment_type_manager
   * @param \Drupal\commerce_payment\PaymentMethodTypeManager $payment_method_type_manager
   * @param \Drupal\Component\Datetime\TimeInterface $time
   * @param \GuzzleHttp\Client $client
   */
  public function __construct(array $configuration, $plugin_id, $plugin_definition, \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager, \Drupal\commerce_payment\PaymentTypeManager $payment_type_manager, \Drupal\commerce_payment\PaymentMethodTypeManager $payment_method_type_manager, \Drupal\Component\Datetime\TimeInterface $time, Client $client) {
    parent::__construct($configuration, $plugin_id, $plugin_definition, $entity_type_manager, $payment_type_manager, $payment_method_type_manager, $time);
    $this->client = $client;
  }

  /**
   * @param \Symfony\Component\DependencyInjection\ContainerInterface $container
   * @param array $configuration
   * @param string $plugin_id
   * @param mixed $plugin_definition
   *
   * @return static
   */
  static public function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
    return new static(
      $configuration,
      $plugin_id,
      $plugin_definition,
      $container->get('entity_type.manager'),
      $container->get('plugin.manager.commerce_payment_type'),
      $container->get('plugin.manager.commerce_payment_method_type'),
      $container->get('datetime.time'),
      $container->get('http_client')
    );
  }

  /**
   * @inheritdoc
   */
  public function defaultConfiguration() {
    return [
      'username' => '080880',
      'restrict_key' => 'yFqqXJh9Pqnugfr',
      'testmode' => 0,
    ] + parent::defaultConfiguration();
  }

  public function buildConfigurationForm(array $form, FormStateInterface $form_state) {
    $form = parent::buildConfigurationForm($form, $form_state); // TODO: Change the autogenerated stub

    $form['username'] = [
      '#type' => 'textfield',
      '#title' => $this->t('Username'),
      '#default_value' => $this->configuration['username'],
      '#description' => $this->t('Your account for the EPN Services. Use 080880 for testing. You can log into eProcessingNetwork.com with this account and 080880pw as the password.'),
      '#required' => TRUE,
    ];
    $form['restrict_key'] = [
      '#type' => 'textfield',
      '#title' => $this->t('Restrict Key'),
      '#default_value' => $this->configuration['restrict_key'],
      '#description' => $this->t('The RestrictKey set in the EPN back end. For test account, use yFqqXJh9Pqnugfr.'),
      '#required' => TRUE,
    ];
    $form['testmode'] = [
      '#type' => 'checkbox',
      '#title' => $this->t('Test mode'),
      '#default_value' => $this->configuration['testmode'],
      '#description' => $this->t('Test mode -- this is only for use on production accounts. The Sandbox account does not support test mode. When in test mode, the EPN account ID is sent instead of the credit card number (which is discarded).'),

    ];
    return $form;
  }

  public function submitConfigurationForm(array &$form, FormStateInterface $form_state) {
    parent::submitConfigurationForm($form, $form_state); // TODO: Change the autogenerated stub

    if (!$form_state->getErrors()) {
      $values = $form_state->getValue($form['#parents']);
      $this->configuration['username'] = $values['username'];
      $this->configuration['restrict_key'] = $values['restrict_key'];
      $this->configuration['testmode'] = $values['testmode'];
      $this->configuration['payment_mode'] = $values['payment_mode'];
    }
  }

  /**
   * @inheritDoc
   */
  public function createPayment(PaymentInterface $payment, $capture = TRUE) {
    $this->assertPaymentState($payment, ['new']);
    $payment_method = $payment->getPaymentMethod();
    $this->assertPaymentMethod($payment_method);
    $amount = $payment->getAmount();

    $order = $payment->getOrder();
    $owner = $payment_method->getOwner();

    $profile = $payment_method->getBillingProfile();
    /** @var \Drupal\address\Plugin\Field\FieldType\AddressItem $billing_info */
    $billing_info = $profile->get('address')->first();

    if ($amount->getNumber() > 0) {
      $trantype = $capture ? 'Sale' : 'AuthOnly';

      $data = [
        'Total' => $amount->getNumber(),
        'Address' => $billing_info->getAddressLine1(),
        'Zip' => $billing_info->getPostalCode(),
        'Email' => $owner->getEmail(),

        // TranType: AuthOnly, Auth2Sale, AuthDel, Sale, AuthConvert, Void,
        //   Return, Store, Recur
        'TranType' => $trantype,

        // following items are optional:
        'Company' => $billing_info->getOrganization(),
        'FirstName' => $billing_info->getGivenName(),
        'LastName' => $billing_info->getFamilyName(),
        'City' => $billing_info->getLocality(),
        'State' => substr($billing_info->getAdministrativeArea(), -2),
        //'Phone' => $billing_info->getGivenName(),
        // use previously stored cc details: (leave CardNo blank)
        'TransID' => $payment_method->getRemoteId(),
      ];

      $this->_standard_fields($data);

      // Initializing the profile to charge and adding it to the transaction.
      $customer_profile_id = $this->getRemoteCustomerId($owner);

      // Anonymous users get the customer profile and payment profile ids from
      // the payment method remote id.
      if (!$customer_profile_id) {
        list($customer_profile_id, $payment_profile_id) = explode('|', $payment_method->getRemoteId());
      }
      else {
        $payment_profile_id = $payment_method->getRemoteId();
      }

      $data['Inv'] = $order->getOrderNumber() ?: $order->id();

      // PC Level 2 adds the following fields:
      // 'Tax' => taxamount,
      // 'CustCode' => $order_id,
      // Tax is a line item... iterate through line items to get tax:
      $tax = 0;
      foreach ($order->getItems() as $line_item) {
        foreach ($line_item->getAdjustments() as $adjustment) {
          if ($adjustment->getType() == 'tax') {
            $adjust = $adjustment->getAmount()->getNumber() * $line_item->getQuantity();
            $tax += $adjust;
          }
        }
      }

      $data['Tax'] = $tax;
      $data['CustCode'] = $order->getOrderNumber() ?: $order->id();

      $response = $this->_post_transaction($data, $payment_method);


      $next_state = $capture ? 'completed' : 'authorization';
      $payment->setState($next_state);
      $payment->setRemoteId($response['TransId']);
      $payment->save();
    }
  }

  /**
   * @inheritDoc
   */
  public function capturePayment(PaymentInterface $payment, Price $amount = NULL) {
    $this->assertPaymentState($payment, ['authorization']);
    // If not specified, capture the entire amount.
    $amount = $amount ?: $payment->getAmount();

    // Perform the capture request here, throw an exception if it fails.
    // See \Drupal\commerce_payment\Exception for the available exceptions.
    $remote_id = $payment->getRemoteId();
    $number = $amount->getNumber();

    $data = [
      'TranType' => 'Auth2Sale',
      'Total' => $number,
      'TransId' => $remote_id,
    ];
    $this->_standard_fields($data);

    $response = $this->_post_transaction($data, $payment->getPaymentMethod());

    $payment->setState('completed');
    $payment->setAmount($amount);
    $payment->save();
  }

  /**
   * @inheritDoc
   */
  public function createPaymentMethod(PaymentMethodInterface $payment_method, array $payment_details) {
    $required_keys = [
      // The expected keys are payment gateway specific and usually match
      // the PaymentMethodAddForm form elements. They are expected to be valid.
      'type', 'number', 'expiration',
    ];
    foreach ($required_keys as $required_key) {
      if (empty($payment_details[$required_key])) {
        throw new \InvalidArgumentException(sprintf('$payment_details must contain the %s key.', $required_key));
      }
    }

    // If the remote API needs a remote customer to be created.
    $owner = $payment_method->getOwner();
    if ($owner && $owner->isAuthenticated()) {
      $customer_id = $this->getRemoteCustomerId($owner);
      // If $customer_id is empty, create the customer remotely and then do
      // $this->setRemoteCustomerId($owner, $customer_id);
      // $owner->save();
    }

    if (!$payment_method->getRemoteId()) {
      $profile = $payment_method->getBillingProfile();
      /** @var \Drupal\address\Plugin\Field\FieldType\AddressItem $billing_info */
      $billing_info = $profile->get('address')->first();

      $data = [
        'TranType' => 'Store',
        'Address' => $billing_info->getAddressLine1(),
        'Zip' => $billing_info->getPostalCode(),
        'Email' => $owner->getEmail(),
        // following items are optional:
        'Company' => $billing_info->getOrganization(),
        'FirstName' => $billing_info->getGivenName(),
        'LastName' => $billing_info->getFamilyName(),
        'City' => $billing_info->getLocality(),
        'State' => substr($billing_info->getAdministrativeArea(), -2),
      ];
      $this->_standard_fields($data);

      $data['CardNo'] = $payment_details['number'];
      $data['ExpMonth'] = $payment_details['expiration']['month'];
      $data['ExpYear'] = $payment_details['expiration']['year'];

      if (!empty($payment_details['security_code'])) {
        $data['CVV2'] = $payment_details['security_code'];
        $data['CVV2Type'] = 1;
      } else {
        $data['CVV2Type'] = 0;
      }

      // Perform the create request here, throw an exception if it fails.
      // See \Drupal\commerce_payment\Exception for the available exceptions.
      // You might need to do different API requests based on whether the
      // payment method is reusable: $payment_method->isReusable().
      // Non-reusable payment methods usually have an expiration timestamp.
      $response = $this->_post_transaction($data, $payment_method);

      $payment_method->card_type = $payment_details['type'];
      // Only the last 4 numbers are safe to store.
      $payment_method->card_number = substr($payment_details['number'], -4);
      $payment_method->card_exp_month = $payment_details['expiration']['month'];
      $payment_method->card_exp_year = $payment_details['expiration']['year'];
      $expires = CreditCard::calculateExpirationTimestamp($payment_details['expiration']['month'], $payment_details['expiration']['year']);
      // The remote ID returned by the request.
      $remote_id = $response['TransId'];

      $payment_method->setRemoteId($remote_id);
      $payment_method->setExpiresTime($expires);
      $payment_method->save();

    }
  }

  /**
   * @inheritDoc
   */
  public function deletePaymentMethod(PaymentMethodInterface $payment_method) {
    // Delete the remote record here, throw an exception if it fails.
    $owner = $payment_method->getOwner();
    $customer_id = $this->getRemoteCustomerId($owner);
    // epn does not support removing a TransId.
    // Delete the local entity.
    $payment_method->delete();
  }

  /**
   * @inheritDoc
   */
  public function voidPayment(PaymentInterface $payment) {
    $this->assertPaymentState($payment, ['authorization']);

    $payment_method = $payment->getPaymentMethod();
    $amount = $payment->getAmount();

    $data = [
      'TranType' => 'Auth2Sale',
      'Total' => $amount->getNumber(),
      'TransId' => $payment->getRemoteId(),
    ];
    $this->_standard_fields($data);

    $response = $this->_post_transaction($data, $payment_method);

    $payment->setState('authorization_voided');
    $payment->save();
  }

  /**
   * @inheritDoc
   */
  public function refundPayment(PaymentInterface $payment, Price $amount = NULL) {
    $this->assertPaymentState($payment, ['completed', 'partially_refunded']);
    // If not specified, refund the entire amount.
    $amount = $amount ?: $payment->getAmount();
    $this->assertRefundAmount($payment, $amount);
    $payment_method = $payment->getPaymentMethod();

    $data = [
      'TranType' => 'Return',
      'Total' => $amount->getNumber(),
      'TransId' => $payment_method->getRemoteId(),
    ];
    $this->_standard_fields($data);

    $response = $this->_post_transaction($data, $payment_method);

    $old_refunded_amount = $payment->getRefundedAmount();
    $new_refunded_amount = $old_refunded_amount->add($amount);
    if ($new_refunded_amount->lessThan($payment->getAmount())) {
      $payment->setState('partially_refunded');
    }
    else {
      $payment->setState('refunded');
    }

    $payment->setRefundedAmount($new_refunded_amount);
    $payment->save();
  }

  /**
   * Add standard fields needed for all EPN calls.
   *
   * @param array $data
   *   The data array to be posted.
   */
  private function _standard_fields(&$data) {
    $data['ePNAccount'] = $this->configuration['username'];
    $data['RestrictKey'] = $this->configuration['restrict_key'];
    $data['HTML'] = 'No'; // This returns raw CSV, otherwise CSV is wrapped in HTML
    $data['Inv'] = 'report'; // can be overridden after this function call
  }

  /**
   * Do actual post to EPN.
   *
   * @param array $data
   *   Array of data to post.
   * @param \Drupal\commerce_payment\Entity\PaymentInterface $payment
   *   Payment interface for order.
   *
   * @return array
   */
  private function _post_transaction($data, PaymentMethodInterface $payment_method) {
    /** @var \Drupal\Core\Session\AccountInterface $owner */
    $owner = $payment_method->getOwner();
    try {
      $response = $this->client->post(
        UC_EPN_HOST . UC_EPN_TRANSPATH,
        [
          'form_params' => $data,
        ]
      );
    } catch (\Exception $exception) {
      throw new InvalidResponseException($exception->getMessage(), $exception->getCode(), $exception);
    }

    if ($response->getStatusCode() == '200') {
      $body = $response->getBody();
      $parts = str_getcsv($body);
      // $parts[0] - starts with 'Y' or 'N' or 'U', then result
      // $parts[1] - AVS result
      // $parts[2] - CVV result
      // $parts[3] - Inv number (if Inv parameter passed)
      // $parts[4] - trans id (if Inv parameter passed. Format: timestamp-acct-inv)
      // Approved - Success!
      $status = substr($parts[0], 0, 1);
      $responsecode = substr($parts[0], 1);

      $result = [
        'uid' => $owner->id(),
        'TransId' => $parts[4],
      ];
      switch ($status) {
        case 'Y':
          $message = $this->t('Credit card payment processed successfully. Transaction ID: %trans', ['%trans' => $responsecode]);
          $result['message'] = $result['comment'] = $message;
          $result['avs'] = $parts[1];
          $result['cvv'] = $parts[2];
          $result['inv'] = $parts[3];
          $result['success'] = TRUE;
          return $result;
        case 'N': // declined
          $message = $this->t('Credit card declined. Reason code: %text', ['%text' => $responsecode]);
          throw new DeclineException($message);

        case 'U': // unable
        default:
          $message = $this->t('Credit card error. Reason code: %text', ['%text' => $responsecode]);
          throw new InvalidRequestException($message);
      }
    }

  }

}
