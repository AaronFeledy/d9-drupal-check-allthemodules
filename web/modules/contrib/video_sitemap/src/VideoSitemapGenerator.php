<?php

namespace Drupal\video_sitemap;

use Drupal\Component\Datetime\TimeInterface;
use Drupal\Component\Plugin\PluginManagerInterface;
use Drupal\Component\Utility\Xss;
use Drupal\Core\Config\ConfigFactoryInterface;
use Drupal\Core\Database\Connection;
use Drupal\Core\Datetime\DateFormatterInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityTypeManagerInterface;
use Drupal\Core\Queue\QueueFactory;
use Drupal\Core\Queue\QueueWorkerManagerInterface;
use Drupal\Core\Url;
use Drupal\datetime\Plugin\Field\FieldType\DateTimeItemInterface;
use Drupal\media\MediaInterface;
use Drupal\node\NodeInterface;

/**
 * Class VideoSitemapGenerator.
 *
 * @package Drupal\video_sitemap
 */
class VideoSitemapGenerator {

  use BatchTrait;

  const VIDEO_SITEMAP_CHUNK_SIZE = 50000;
  const VIDEO_SITEMAP_FIRST_DELTA = 1;
  const VIDEO_SITEMAP_INDEX_DELTA = 0;
  const XML_VERSION = '1.0';
  const ENCODING = 'UTF-8';
  const XMLNS = 'http://www.sitemaps.org/schemas/sitemap/0.9';
  const XMLNS_VIDEO = 'http://www.google.com/schemas/sitemap-video/1.1';
  const GENERATED_BY = 'Generated by the Video Sitemap Drupal module: https://www.drupal.org/project/video_sitemap.';

  /**
   * Sitepam XML attributes.
   *
   * @var array
   */
  protected static $attributes = [
    'xmlns' => self::XMLNS,
    'xmlns:video' => self::XMLNS_VIDEO,
  ];

  /**
   * The queue service.
   *
   * @var \Drupal\Core\Queue\QueueFactory
   */
  protected $queueFactory;

  /**
   * The queue plugin manager.
   *
   * @var \Drupal\Core\Queue\QueueWorkerManagerInterface
   */
  protected $queueManager;

  /**
   * The entity type manager.
   *
   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
   */
  protected $entityTypeManager;

  /**
   * Video location plugin manager.
   *
   * @var \Drupal\Component\Plugin\PluginManagerInterface
   */
  protected $locationManager;

  /**
   * The module config.
   *
   * @var \Drupal\Core\Config\Config
   */
  protected $config;

  /**
   * The database connection.
   *
   * @var \Drupal\Core\Database\Connection
   */
  protected $connection;

  /**
   * The Sitemap writer service.
   *
   * @var \Drupal\video_sitemap\SitemapWriter
   */
  protected $writer;

  /**
   * The time service.
   *
   * @var \Drupal\Component\Datetime\TimeInterface
   */
  protected $time;

  /**
   * The date formatter service.
   *
   * @var \Drupal\Core\Datetime\DateFormatterInterface
   */
  protected $dateFormatter;

  /**
   * Constructs a VideoSitemapGenerator object.
   *
   * @param \Drupal\Core\Queue\QueueFactory $queue_factory
   *   The queue service.
   * @param \Drupal\Core\Queue\QueueWorkerManagerInterface $queue_manager
   *   The queue plugin manager.
   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
   *   The entity type manager.
   * @param \Drupal\Component\Plugin\PluginManagerInterface $location_manager
   *   Video location plugin manager.
   * @param \Drupal\Core\Config\ConfigFactoryInterface $config
   *   The config factory.
   * @param \Drupal\Core\Database\Connection $connection
   *   The Database connection.
   * @param \Drupal\video_sitemap\SitemapWriter $sitemap_writer
   *   The Sitemap writer service.
   * @param \Drupal\Component\Datetime\TimeInterface $time
   *   The time service.
   * @param \Drupal\Core\Datetime\DateFormatterInterface $date_formatter
   *   The date formatter service.
   */
  public function __construct(
    QueueFactory $queue_factory,
    QueueWorkerManagerInterface $queue_manager,
    EntityTypeManagerInterface $entity_type_manager,
    PluginManagerInterface $location_manager,
    ConfigFactoryInterface $config,
    Connection $connection,
    SitemapWriter $sitemap_writer,
    TimeInterface $time,
    DateFormatterInterface $date_formatter
  ) {
    $this->queueFactory = $queue_factory;
    $this->queueManager = $queue_manager;
    $this->entityTypeManager = $entity_type_manager;
    $this->locationManager = $location_manager;
    $this->config = $config->get('video_sitemap.settings');
    $this->connection = $connection;
    $this->writer = $sitemap_writer;
    $this->time = $time;
    $this->dateFormatter = $date_formatter;
  }

  /**
   * Generates video sitemap.
   *
   * @param string $from
   *   Can be 'form', 'drush' and 'cron'.
   */
  public function generateSitemap($from = 'form') {
    switch ($from) {
      case 'form':
      case 'drush':
        $this->rebuildQueue();
        $this->batchGenerateSitemap();
        break;

      case 'cron':
        $this->writeSitemap();
        break;
    }
  }

  /**
   * Writes sitemap XML string in the database based on index.
   */
  public function writeSitemap() {
    // Clear all previous records.
    $this->connection->delete('video_sitemap')->execute();

    $count = $this->connection->select('video_sitemap_index')
      ->countQuery()
      ->execute()
      ->fetchField();

    if ($count > self::VIDEO_SITEMAP_CHUNK_SIZE) {
      $page_count = ceil($count / self::VIDEO_SITEMAP_CHUNK_SIZE);
      for ($page = 0; $page < $page_count; $page++) {
        $start = self::VIDEO_SITEMAP_CHUNK_SIZE * $page;
        $records = $this->selectSitemapChunk($start);
        $this->writeSitemapChunk($records, $page + 1);
      }
      $this->writeSitemapIndexRecord($page_count);
    }
    else {
      $records = $this->selectSitemapChunk();
      $this->writeSitemapChunk($records);
    }
  }

  /**
   * Selects a sitemap index chunk.
   *
   * @param int $start
   *   Which position of index we are processing.
   *
   * @return mixed
   *   Database query result.
   */
  protected function selectSitemapChunk($start = 0) {
    $query = $this->connection->select('video_sitemap_index', 'vsi');
    $query->fields('vsi', []);
    $query->orderBy('loc_id');
    $query->range($start, self::VIDEO_SITEMAP_CHUNK_SIZE);
    return $query->execute()->fetchAll();
  }

  /**
   * Stores a sitemap chunk XML string in the database.
   *
   * @param array $records
   *   Sitemap index records.
   * @param int $delta
   *   Sitemap page.
   */
  protected function writeSitemapChunk(array $records, $delta = 1) {
    // Group results by loc property as there can by multiple resources at one location.
    $links = [];
    foreach ($records as $row) {
      $links[] = $row;
    }
    $xml = $this->getXml($links);
    $this->writeSitemapRecord($xml, $delta);
  }

  /**
   * Creates a sitemap XML string and stores it in the database.
   */
  protected function writeSitemapIndexRecord($page_count) {
    $this->writer->openMemory();
    $this->writer->setIndent(TRUE);
    $this->writer->startDocument(self::XML_VERSION, self::ENCODING);
    $this->writer->writeComment(self::GENERATED_BY);
    $this->writer->startElement('urlset');
    $attributes = self::$attributes;
    foreach ($attributes as $name => $value) {
      $this->writer->writeAttribute($name, $value);
    }
    $this->writer->startElement('sitemapindex');
    for ($page = 0; $page < $page_count; $page++) {
      $this->writer->startElement('sitemap');
      $url = Url::fromRoute('video_sitemap.sitemap', [], [
        'query' => ['page' => $page + 1],
        'absolute' => TRUE,
      ])->toString();
      $this->writer->writeElement('loc', $url);
      $this->writer->writeElement('lastmod', $this->dateFormatter->format($this->time->getCurrentTime(), DateTimeItemInterface::DATETIME_STORAGE_FORMAT));
      $this->writer->endElement();
    }
    $this->writer->endElement();
    $this->writer->endDocument();
    $xml = $this->writer->outputMemory();
    $this->writeSitemapRecord($xml, self::VIDEO_SITEMAP_INDEX_DELTA);
  }

  /**
   * Generates and returns a sitemap chunk.
   *
   * @param array $links
   *   All links for the given chunk.
   *
   * @return string
   *   Sitemap chunk
   */
  protected function getXml(array $links) {
    $this->writer->openMemory();
    $this->writer->setIndent(TRUE);
    $this->writer->startDocument(self::XML_VERSION, self::ENCODING);
    $this->writer->writeComment(self::GENERATED_BY);
    $this->writer->startElement('urlset');
    $attributes = self::$attributes;
    foreach ($attributes as $name => $value) {
      $this->writer->writeAttribute($name, $value);
    }

    foreach ($links as $link) {
      $this->writer->startElement('url');
      $this->writer->writeElement('loc', $link->loc);
      $data = unserialize($link->data);
      foreach ($data as $video_item) {
        $this->writer->startElement('video:video');
        $this->writer->writeElement('video:thumbnail_loc', $video_item['thumbnail_loc']);
        $this->writer->writeElement('video:title', $video_item['title']);
        $this->writer->writeElement('video:description', $video_item['description']);
        if (!empty($video_item['content_loc'])) {
          $this->writer->writeElement('video:content_loc', $video_item['content_loc']);
        }
        else {
          $this->writer->writeElement('video:player_loc', $video_item['player_loc']);
        }
        $this->writer->endElement();
      }
      $this->writer->endElement();
    }
    $this->writer->endElement();
    $this->writer->endDocument();
    return $this->writer->outputMemory();
  }

  /**
   * Write sitemap chunk record.
   *
   * @param string $xml
   *   XML string.
   * @param int $delta
   *   Sitemap page number.
   *
   * @throws \Exception
   */
  public function writeSitemapRecord($xml, $delta) {
    $this->connection->insert('video_sitemap')->fields([
      'delta' => $delta,
      'sitemap_string' => $xml,
      'sitemap_created' => $this->time->getRequestTime(),
    ])->execute();
  }

  /**
   * Stores videos used on a node as a sitemap index data.
   *
   * @param \Drupal\node\NodeInterface $node
   *   Node entity.
   *
   * @throws \Drupal\Core\Entity\EntityMalformedException
   * @throws \Exception
   */
  public function processVideoUsageOnNode(NodeInterface $node) {
    $data = $this->getMediaValuesFromEntity($node);
    if (!empty($data)) {
      $record = [
        'loc_id' => $node->id(),
        'loc' => $node->toUrl()->toString(),
        'data' => serialize($data),
      ];
      $this->connection->merge('video_sitemap_index')
        ->condition('loc_id', $record['loc_id'])
        ->fields($record)
        ->execute();
    }
    else {
      $this->connection->delete('video_sitemap_index')
        ->condition('loc_id', $node->id())
        ->execute();
    }
  }

  /**
   * Searches for videos used on a node.
   *
   * @param \Drupal\Core\Entity\EntityInterface $entity
   *   Entity item.
   *
   * @return array
   *   Sitemap index data for a give node.
   *
   * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
   * @throws \Drupal\Component\Plugin\Exception\PluginException
   * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
   */
  private function getMediaValuesFromEntity(EntityInterface $entity) {
    $records = [];
    $bundle = $this->config->get('media_video_bundle');
    $fields = $this->getFields($entity, ['media'], $bundle);
    if (empty($fields)) {
      return $records;
    }

    $media_storage = $this->entityTypeManager->getStorage('media');
    $plugin_id = $this->config->get('video_location_plugin');
    if (empty($plugin_id)) {
      return $records;
    }
    $plugin = $this->locationManager->createInstance($plugin_id);
    foreach ($fields as $field) {
      $field_values = $entity->get($field)->getValue();
      $target_ids = array_column($field_values, 'target_id');
      $media_entities = $media_storage->loadMultiple($target_ids);
      foreach ($media_entities as $media) {
        if (!$media->isPublished()) {
          continue;
        }
        $title = $media->label();
        $thumbnail_loc = $plugin->getThumbnailLoc($media);
        $player_loc = $plugin->getPlayerLoc($media);
        $content_loc = $plugin->getContentLoc($media);
        $description = $this->getDescriptionValue($media);
        // All of these values are required for the video the sitemap.
        if ($title && $thumbnail_loc && ($content_loc || $player_loc) && $description) {
          $records[] = [
            'title' => $title,
            'thumbnail_loc' => $thumbnail_loc,
            'player_loc' => $player_loc,
            'content_loc' => $content_loc,
            'description' => $description,
          ];
        }
      }
    }
    $children = $this->getChildren($entity);
    foreach ($children as $child) {
      $records = array_merge_recursive($records, $this->getMediaValuesFromEntity($child));
    }

    return array_filter($records);
  }

  /**
   * Callback to find any children referenced entities.
   *
   * @param \Drupal\Core\Entity\EntityInterface $entity
   *   Entity item.
   *
   * @return array
   *   Child items.
   *
   * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
   * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
   */
  protected function getChildren(EntityInterface $entity) {
    $children = [];
    $type = 'paragraph';
    $storage = $this->entityTypeManager->getStorage($type);
    $fields = $this->getFields($entity, [$type]);
    foreach ($fields as $field) {
      $field_values = $entity->get($field)->getValue();
      $target_ids = array_column($field_values, 'target_id');
      $entities = $storage->loadMultiple($target_ids);
      foreach ($entities as $entity) {
        $children[] = $entity;
      }
    }
    return $children;
  }

  /**
   * Gets an entity type fields of entity reference type.
   *
   * @param \Drupal\Core\Entity\EntityInterface $entity
   *   Entity item.
   * @param array $target_types
   *   Field types to search.
   * @param mixed $target_bundle
   *   Referenced entity bundle.
   *
   * @return array
   *   Field definitions.
   */
  protected function getFields(EntityInterface $entity, array $target_types, $target_bundle = NULL) {
    $fields = [];
    if (empty($target_types)) {
      return $fields;
    }

    /** @var \Drupal\Core\Field\FieldDefinitionInterface[] $fields */
    $fields_defintion = \Drupal::getContainer()
      ->get('entity_field.manager')
      ->getFieldDefinitions($entity->getEntityTypeId(), $entity->bundle());
    foreach ($fields_defintion as $key => $field) {
      /** @var \Drupal\Core\Field\BaseFieldDefinition $field */
      if (!in_array($field->getType(), ['entity_reference', 'entity_reference_revisions'])) {
        continue;
      }
      $field_settings = $field->getSettings();
      if (!in_array($field_settings['target_type'], $target_types)) {
        continue;
      }
      if (empty($target_bundle) || in_array($target_bundle, $field_settings['handler_settings']['target_bundles'])) {
        $fields[] = $key;
      }
    }
    return $fields;
  }

  /**
   * Gets Media entity description field value.
   *
   * @param \Drupal\media\MediaInterface $media
   *   Media item.
   *
   * @return string
   *   Field value.
   */
  protected function getDescriptionValue(MediaInterface $media) {
    $description = '';
    $description_field = $this->config->get('video_description_field');
    if (empty($description_field)) {
      return $description;
    }
    if (!$media->hasField($description_field)) {
      return $description;
    }
    $field_value = $media->get($description_field)->getValue();
    if (!empty($field_value)) {
      $description = Xss::filter($field_value[0]['value']);
      $description = trim(substr($description, 0, 2048));
    }
    return $description;
  }

  /**
   * Rebuilds video sitemap index queue.
   */
  public function rebuildQueue() {
    $queue = $this->queueFactory->get('node_with_video_queue');
    if ($queue->numberOfItems() > 0) {
      $queue->deleteQueue();
    }
    $entityTypeStorage = $this->entityTypeManager->getStorage('node');
    $query = $entityTypeStorage->getQuery();
    $query->condition('status', NodeInterface::PUBLISHED);
    $nids = $query->execute();
    foreach ($nids as $nid) {
      $queue->createItem(['entity_type' => 'node', 'entity_id' => $nid]);
    }
  }

  /**
   * Returns a sitemap string store in the database.
   *
   * @param int $delta
   *   Sitemap page.
   *
   * @return string|false
   *   If no sitemap delta is provided, either a sitemap index is returned, or
   *   the whole sitemap, if the amount of links does not exceed the max links
   *   setting. If a sitemap delta is provided, a sitemap chunk is returned.
   *   Returns false if the sitemap is not retrievable from the database.
   */
  public function getSitemap($delta = NULL) {
    $chunk_info = $this->getChunkInfo();

    if (empty($delta) || !isset($chunk_info[$delta])) {

      if (count($chunk_info) == 1) {
        $chunk = $this->fetchSitemapChunk(self::VIDEO_SITEMAP_FIRST_DELTA);
        return $chunk->sitemap_string;
      }
      else {
        // Return sitemap chunk if there is only one chunk.
        return isset($chunk_info[self::VIDEO_SITEMAP_INDEX_DELTA])
          ? $this->fetchSitemapChunk(self::VIDEO_SITEMAP_INDEX_DELTA)
            ->sitemap_string
          : FALSE;
      }
    }
    else {
      // Return specific sitemap chunk.
      return $this->fetchSitemapChunk($delta)->sitemap_string;
    }
  }

  /**
   * Get sitemap chunk info.
   *
   * @return mixed
   *   Database query result.
   */
  protected function getChunkInfo() {
    $result = $this->connection->select('video_sitemap', 's')
      ->fields('s', ['id', 'delta', 'sitemap_created'])
      ->execute();

    return $result->fetchAllAssoc('delta');
  }

  /**
   * Fetches a single sitemap chunk by ID.
   *
   * @param int $delta
   *   The chunk delta.
   *
   * @return object
   *   A sitemap chunk object.
   */
  protected function fetchSitemapChunk($delta) {
    return $this->connection->select('video_sitemap', 's')
      ->fields('s', [])
      ->condition('s.delta', $delta)
      ->execute()
      ->fetchObject();
  }

  /**
   * Gets last sitemap generation timestamp.
   *
   * @return int
   *   Timestamp.
   */
  public function getLastGenerated() {
    $query = $this->connection->select('video_sitemap', 's')
      ->fields('s', ['sitemap_created'])
      ->execute();
    $result = $query->fetchField();
    return !empty($result) ? $result : 0;
  }

}
