<?php

/**
 * @file
 * Contains all backend logic for the Moderate mmenu module.
 */

/**
 * Implements hook_preprocess_page().
 *
 * Create a off-screen menu to moderate the current node.
 */
function moderate_mmenu_preprocess_page(&$variables) {
  $user = \Drupal::currentUser();

  // Check to make sure that this page load meets our requirements.
  if (!\Drupal::service('router.admin_context')->isAdminRoute() && isset($variables['node']) && $user->isAuthenticated()) {
    // Assemble the main menu.
    $menu = [];

    // Add blocks assigned to our region.
    if (isset($variables['page']['moderate_mmenu'])) {
      $menu['region'] = $variables['page']['moderate_mmenu'];
    }

    $node = $variables['node'];

    // Return early if the node variable is not a node object.
    if (!($node instanceof \Drupal\node\NodeInterface)) {
      return;
    }

    // Process a title and subtitle for the menu link button.
    $title = moderate_mmenu_get_menu_title($node);
    $subtitle = moderate_mmenu_get_menu_subtitle($node);

    // Create the menu link button.
    $menu_link = [];
    $menu_link[] = ['#markup' => '<div class="moderate-mmenu-title">' . $title . '</div>'];
    if (!empty($subtitle)) {
      $menu_link[] = ['#markup' => '<div class="moderate-mmenu-subtitle">' . $subtitle . '</div>'];
    }

    // Add our mmenu elements to the page.
    $page = &$variables['page'];

    $page['content'][] = [
      '#prefix' => '<nav id="moderate-mmenu">',
      '#type' => 'container',
      '#suffix' => '</nav>',
      0 => $menu,
    ];

    $page['content'][] = [
      '#prefix' => '<a class="button local-task-link" id="moderate-mmenu-link" href="#moderate-mmenu">',
      '#type' => 'container',
      '#suffix' => '</a>',
      0 => $menu_link,
    ];

    // Attach our required libraries.
    $page['content']['#attached']['library'][] = 'moderate_mmenu/moderate_mmenu';
    $page['content']['#attached']['library'][] = 'moderate_mmenu/jQuery.mmenu';
  }
}

/**
 * Implements hook_system_info_alter().
 *
 * Adds a dummy region to the current theme so that blocks can be assigned to
 * the menu.
 */
function moderate_mmenu_system_info_alter(array &$info, \Drupal\Core\Extension\Extension $file, $type) {
  if (isset($info['regions'])) {
    $info['regions'] = array_merge($info['regions'], ['moderate_mmenu' => 'Moderate mmenu']);
  }
}

/**
 * Generates a menu link title based on the current node type.
 *
 * @param \Drupal\node\Entity\Node $node
 *   The current node.
 *
 * @return string
 *   A title which informs the user of the current Node's bundle.
 */
function moderate_mmenu_get_menu_title($node) {
  $title = t('Moderate');
  if ($type = $node->getType()) {
    $type = \Drupal::entityTypeManager()->getStorage('node_type')->load($type);
    $title .= ' ' . $type->label();
  }
  return $title;
}

/**
 * Generates a menu link title based on the current node's status.
 *
 * Supports Workbench Moderation and base Drupal.
 *
 * @param \Drupal\node\Entity\Node $node
 *   The current node.
 *
 * @return string
 *   A subtitle containing information about the Node's status.
 */
function moderate_mmenu_get_menu_subtitle($node) {
  $status = NULL;
  $workbench_enabled = \Drupal::moduleHandler()->moduleExists('workbench_moderation');

  // Add Workbench Moderation specific messages.
  if ($workbench_enabled && isset($node->moderation_state) && $node->moderation_state->count() > 0) {
    $status = moderate_mmenu_get_workbench_state_label($node);
  }
  else {
    // This node or site doesn't have workbench enabled.
    $status = $node->isPublished() ? t('Published') : t('Unpublished');
  }

  // Add node status to the subtitle.
  $subtitle = t('Currently Viewing: @status', ['@status' => $status]);

  // Check if a draft exists and append that information to the subtitle.
  if ($workbench_enabled && isset($node->moderation_state)) {
    /** @var \Drupal\workbench_moderation\ModerationInformation $moderation_information */
    $moderation_information = \Drupal::service('workbench_moderation.moderation_information');
    /** @var \Drupal\node\Entity\Node $latest_node */
    $latest_node = $moderation_information->getLatestRevision('node', $node->id());
    if ($latest_node->getRevisionId() != $node->getRevisionId()) {
      $status = moderate_mmenu_get_workbench_state_label($latest_node);
      $draft_status = $status == 'Draft' ? 'editing' : 'review';
      $subtitle .= '<br /> <i>' . t('Draft available for ' . $draft_status) . '</i>';
    }
  }

  return $subtitle;
}

/**
 * Implements hook_library_info_alter().
 */
function moderate_mmenu_library_info_alter(&$libraries, $extension) {
  // Optionally use the Libraries module to determine our library paths.
  if ($extension == 'moderate_mmenu' && \Drupal::moduleHandler()->moduleExists('libraries')) {
    $mmenu_path = libraries_get_path('jQuery.mmenu') . '/dist';

    $libraries['jQuery.mmenu']['js'] = ['/' . $mmenu_path . '/js/jquery.mmenu.min.all.js' => ['minified' => 'true']];
    $libraries['jQuery.mmenu']['css']['component'] = ['/' . $mmenu_path . '/css/jquery.mmenu.all.css' => []];
  }
}

/**
 * Gets the label of a Node's Workbench Moderation state.
 *
 * @param \Drupal\node\Entity\Node $node
 *   The current node.
 *
 * @return string
 */
function moderate_mmenu_get_workbench_state_label($node) {
  /** @var \Drupal\Core\Field\EntityReferenceFieldItemList $state_list */
  $state_list = $node->moderation_state;
  $bundle_entity = \Drupal::entityTypeManager()->getStorage($node->getEntityType()->getBundleEntityType())->load($node->bundle());
  $state_id = $state_list->first()->target_id ?: $bundle_entity->getThirdPartySetting('workbench_moderation', 'default_moderation_state', FALSE);
  /** @var \Drupal\workbench_moderation\Entity\ModerationState $state */
  $state = \Drupal::entityTypeManager()->getStorage('moderation_state')->load($state_id);
  return $state->label();
}