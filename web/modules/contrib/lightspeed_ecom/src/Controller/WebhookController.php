<?php

namespace Drupal\lightspeed_ecom\Controller;

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Controller\ControllerBase;
use Drupal\Core\Routing\Access\AccessInterface;
use Drupal\lightspeed_ecom\ShopInterface;
use Drupal\lightspeed_ecom\Service\SecurityTokenGeneratorInterface;
use Drupal\lightspeed_ecom\Service\WebhookEvent;
use Drupal\lightspeed_ecom\Service\WebhookRegistryInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

/**
 * Class WebhookController.
 *
 * @package Drupal\lightspeed_ecom\Controller
 */
class WebhookController extends ControllerBase implements AccessInterface {

  /** @var \Drupal\lightspeed_ecom\Service\WebhookRegistryInterface  */
  protected $webhook_registry;

  /** @var \Drupal\lightspeed_ecom\Service\TokenGeneratorInterface  */
  protected $token;

  /**
   * Create a new instance of WebhookController.
   */
  public function __construct(WebhookRegistryInterface $webhook_registry, SecurityTokenGeneratorInterface $token) {
    $this->webhook_registry = $webhook_registry;
    $this->token = $token;
  }

  /**
   * {@inheritdoc}
   */
  public static function create(ContainerInterface $container) {
    return new static(
      $container->get('lightspeed.ecom.webhook_registry'),
      $container->get('lightspeed.ecom.security_token')
    );
  }

  /**
   * Check whether or not an incoming webhook request is allowed.
   *
   * A request is allowed if and only if one of the following condition is true:
   *  - The request contains a valid hash in the custom header X-Signature, as
   *    documented on
   *    http://developers.lightspeedhq.com/ecom/tutorials/webhooks/
   *  - The request contains a `token` query parameter whose value has been
   *    generated by the security token generator.
   *
   * @param \Drupal\lightspeed_ecom\ShopInterface $shop
   *   The Lightspeed eCom shop for the incoming webhook.
   * @param \Symfony\Component\HttpFoundation\Request $request
   *   The incoming webhook request object.
   *
   * @return \Drupal\Core\Access\AccessResult
   */
  public function access(ShopInterface $shop, Request $request) {
    if ($request->headers->has('X-Signature')) {
      // Check signature if present.
      $signature = $request->headers->get('X-Signature');
      $payload = $request->getContent();
      $apiSecret = $shop->apiSecret();
      if ($signature == md5($payload . $apiSecret)) {
        return AccessResult::allowed();
      }
    }
    else if ($request->query->has('token')) {
      // Otherwise, check token.
      if ($this->token->validate($request->query->get('token'), $shop)) {
        return AccessResult::allowed();
      }
    }
    $this->getLogger('lightspeed_ecom_webhook')->warning("Unauthorized webhook request from [@client_ips].", [
      '@client_ips' => implode(', ', $request->getClientIps()),
      'request' => $request
    ]);
    return AccessResult::forbidden();
  }


  /**
   * Handle incoming Webhook request.
   *
   * @param \Symfony\Component\HttpFoundation\Request $request
   * @param \Drupal\lightspeed_ecom\ShopInterface $shop
   *
   * @return \Symfony\Component\HttpFoundation\Response
   */
  public function receive(Request $request, ShopInterface $shop) {
    // Extract group and action from X-Event header.
    if (!$request->headers->has('X-Event')) {
      return new Response('Missing required header: X-Event', Response::HTTP_BAD_REQUEST);
    }
    list($group, $action) = explode('/', $request->headers->get('X-Event'));

    // Extract language from X-Language header.
    if (!$request->headers->has('X-Language')) {
      return new Response('Missing required header: X-Language', Response::HTTP_BAD_REQUEST);
    }
    // FIXME Resolve language to an actual Drupal language object.
    $language = $request->headers->get('X-Language');

    // Extract object ID from X-Group-ID
    $object_id_header = "X-". ucfirst(substr($group, 0, -1)) . "-Id";
    if (!$request->headers->has($object_id_header)) {
      return new Response('Missing required header: ' . $object_id_header, Response::HTTP_BAD_REQUEST);
    }
    $object_id = $request->headers->get($object_id_header);

    // Extract payload (ie. object) from request's body.
    $payload = json_decode($request->getContent(), TRUE);
    $json_error = json_last_error();
    if ($json_error != JSON_ERROR_NONE) {
      $this->getLogger('lightspeed_ecom_webhook')->error("Unable to parse webhook JSON payload (@error)", [
        '@error' => $json_error,
        'request' => $request
      ]);
      return new Response('Invalid JSON', Response::HTTP_BAD_REQUEST);
    }

    // Dispatch the event to listeners.
    $event = new WebhookEvent(
      $group,
      $action,
      $shop->id(),
      $language,
      $object_id,
      $payload
    );
    $this->webhook_registry->dispatch($event);
    return new Response('', Response::HTTP_OK);
  }

}
