<?php

/**
 * @file
 * This module provides block integration with Mailchimp Popups.
 */

use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Entity\ContentEntityInterface;

/**
 * Implements hook_cron().
 */
function service_comment_count_cron() {
  // Get the service comment count services.
  $manager = \Drupal::service('plugin.manager.service_comment_count.service');
  $services = $manager->getServices();

  // Returns the service_comment_count_fetcher queue.
  $queue = \Drupal::queue('service_comment_count_fetcher');

  // Get the maximum number of items, that should be fetched with a single
  // request.
  $items_per_batch = \Drupal::config('service_comment_count.settings')
    ->get('items_per_batch');

  $last_run = \Drupal::state()->get('service_comment_count.last_run', 0);
  if ((\Drupal::time()->getRequestTime() - $last_run) > 3600) {
    // Iterate through the services and create the queue items to be fetched.
    foreach ($services as $plugin_id => $service) {
      if ($service['instance']->isValid()) {
        // Fetch the node ids, to be fetched.
        $nids = $service['instance']->getNids();

        // Split up the results by the given items to be processed per batch.
        $chunks = array_chunk($nids, $items_per_batch);

        // Add each chunk to the queue.
        foreach ($chunks as $chunk) {
          $item = ['plugin_id' => $plugin_id, 'nids' => $chunk];
          $queue->createItem($item);
        }
      }
      else {
        \Drupal::logger('service_comment_count')
          ->error('Service Comment Count Plugin "%plugin_id" is not valid.', ['%plugin_id' => $plugin_id]);
      }
    }

    // Update last run.
    \Drupal::state()->set('service_comment_count.last_run', \Drupal::time()
      ->getRequestTime());
  }
}

/**
 * Implements hook_views_data().
 */
function service_comment_count_views_data() {
  $data = [];

  // Only add relationships to content entity types.
  $entity_types = \Drupal::entityTypeManager()->getDefinitions();
  $entity_types = array_filter($entity_types, function (EntityTypeInterface $entity_type) {
    return $entity_type->entityClassImplements(ContentEntityInterface::class);
  });

  // Iterate through the filtered entity types and add a relationship to the
  // service comment count.
  /** @var \Drupal\Core\Entity\EntityTypeInterface $entity_type */
  foreach ($entity_types as $entity_type) {
    /** @var \Drupal\Core\Entity\EntityTypeInterface $entity_type */
    $base_table = $entity_type->getBaseTable() ?: $entity_type->id();

    $data[$base_table]['service_comment_count'] = [
      'title' => t('Service Comment Count'),
      'help' => t('The service comment count of the entity.'),
      'relationship' => [
        'base' => 'service_comment_count',
        'base field' => 'entity_id',
        'field' => $entity_type->getKey('id'),
        'id' => 'standard',
        'label' => t('Service Comment Count'),
      ],
    ];
  }

  // Create the service comment count group.
  $data['service_comment_count']['table']['group'] = t('Service Comment Count');
  $data['service_comment_count']['table']['provider'] = 'service_comment_count';
  $data['service_comment_count']['table']['join'] = [
    'service_comment_count' => [
      'left_field' => 'entity_id',
      'field' => 'nid',
    ],
  ];

  // Add basic handlers for exposing the comment count.
  $data['service_comment_count']['comment_count'] = [
    'title' => t('Comment Count'),
    'help' => t('The service comment count of the entity.'),

    'field' => [
      // ID of field handler plugin to use.
      'id' => 'standard',
    ],

    'sort' => [
      // ID of sort handler plugin to use.
      'id' => 'standard',
    ],

    'filter' => [
      // ID of filter handler plugin to use.
      'id' => 'string',
    ],

    'argument' => [
      // ID of argument handler plugin to use.
      'id' => 'string',
    ],
  ];

  return $data;
}
