<?php

/**
 * @file
 * Display a dynamic horizontal menu which degrades gracefully if Javascript if
 * not present. See README.txt for more information.
 */

/**
 * Implements hook_block_info().
 * Finds all dynamic menus defined in the database
 * @return
 * record for each dynamic menu in the database, with a generic title and no
 * caching.
 */
function dynamic_persistent_menu_block_info() {
  $block = array();
  $result = db_query('SELECT dpmid, root, timeout FROM {dynamic_persistent_menu}');
  foreach ($result as $record) {
    $block[$record->dpmid]['info'] = t('Dynamic persistent menu #@dpmid', array('@dpmid' => $record->dpmid));
    $block[$record->dpmid]['cache'] = DRUPAL_NO_CACHE;
  }
  return $block;
}

/**
 * Implements hook_block_view().
 * Given a delta, which corresponds to the id of a dynamic menu, unique
 * to the website, returns the block information.
 */
function dynamic_persistent_menu_block_view($delta = 0) {
  $dpm = dynamic_persistent_menu_load($delta);
  if (!isset($dpm->root)) {
    $block['content'] = t('This dynamic persistent menu does not exist (it might have been deleted).');
  } else {
    $params = explode(':', $dpm->root);
    $block['content'] = theme('dynamic_persistent_menu', array('id' => $delta, 'menu' => $params[0], 'parent' => $params[1], 'timeout' => $dpm->timeout), NULL, NULL);
  }
  return $block;
}

/**
 * Implements hook_block_configure().
 * It is possible on admin/config/user-interface/dynamic_persistent_menu to
 * add new dynamic menus. Each dynamic menu can then be edited there or directly
 * on the block config page. This function, along with
 * dynamic_persistent_menu_block_save, below, allows one to modify the
 * configuration directly from the block configuration page.
 */
function dynamic_persistent_menu_block_configure($delta = 0) {
  if (user_access('administer dynamic persistent menu')) {
    $dpm = dynamic_persistent_menu_load($delta);
    $form = dynamic_persistent_menu_setting_base_form($dpm);
    return $form;
  }
}

/**
 * Implements hook_block_save().
 * It is possible on admin/config/user-interface/dynamic_persistent_menu to
 * add new dynamic menus. Each dynamic menu can then be edited there or directly
 * on the block config page. This function, along with
 * dynamic_persistent_menu_block_configure, above, allows one to modify the
 * configuration directly from the block configuration page.
 */
function dynamic_persistent_menu_block_save($delta = 0, $edit = array()) {
  if (user_access('administer dynamic persistent menu')) {
    $dpm = dynamic_persistent_menu_load($delta);
    $form = dynamic_persistent_menu_setting_base_form($dpm);
    return $form;
  }
}

/**
 * Implements hook_menu().
 */
function dynamic_persistent_menu_menu() {
  // list of defined dymanic menus
  $items['admin/config/user-interface/dynamic_persistent_menu'] = array(
    'title' => 'Dynamic persistent menu',
    'page callback' => 'dynamic_persistent_menu_settings',
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => array('administer dynamic persistent menu'),
    'file' => 'dynamic_persistent_menu.admin.inc',
  );
  // list of defined dymanic menus (default tab).
  $items['admin/config/user-interface/dynamic_persistent_menu/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'access arguments' => array('administer dynamic persistent menu'),
  );
  // New dymanic menu
  $items['admin/config/user-interface/dynamic_persistent_menu/add'] = array(
    'title' => 'New',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('dynamic_persistent_menu_settings_form'),
    'access arguments' => array('administer dynamic persistent menu'),
    'file' => 'dynamic_persistent_menu.admin.inc',
  );
  // Edit dynamic menu
  $items['admin/config/user-interface/dynamic_persistent_menu/%dynamic_persistent_menu/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
      // the number in the array below refers to the argument
      // number in the path. Please make sure that if the path changes,
      // you change the number as well. e.g. above, "admin" is argument 0,
      // user-interface is arguemnt 2, and the wildcard representing
      // the dynamic persistent menu id is argument 4.
    'page arguments' => array('dynamic_persistent_menu_settings_form', 4),
    'access arguments' => array('administer dynamic persistent menu'),
    'file' => 'dynamic_persistent_menu.admin.inc',
  );
  // Delete dynamic menu
  $items['admin/config/user-interface/dynamic_persistent_menu/%dynamic_persistent_menu/delete'] = array(
    'title' => 'Delete',
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
      // the number in the array below refers to the argument
      // number in the path. Please make sure that if the path changes,
      // you change the number as well. e.g. above, "admin" is argument 0,
      // user-interface is arguemnt 2, and the wildcard representing
      // the dynamic persistent menu id is argument 4.
    'page arguments' => array('dynamic_persistent_menu_delete_form', 4),
    'access arguments' => array('administer dynamic persistent menu'),
    'file' => 'dynamic_persistent_menu.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function dynamic_persistent_menu_permission() {
  return array(
    'administer dynamic persistent menu' => array(
      'title' => t('administer dynamic persistent menu'),
      'description' => t('Add, modify, and delete dynamic persistent menus.'),
    ),
  );
}

/**
 * Implements of hook_theme().
 */
function dynamic_persistent_menu_theme() {
  return array(
    // A complete dynamic persistent menu
    'dynamic_persistent_menu' => array(
      'arguments' => array(
        'id' => NULL,
        'menu' => NULL,
        'parent' => NULL,
        'timeout' => NULL,
      ),
      'file' => 'dynamic_persistent_menu.theme.inc', 
    ),
    // A complete dynamic persistent menu
    'dynamic_persistent_menu_menu_item' => array(
      'arguments' => array(
        'link' => NULL,
        'extra_class' => NULL,
        'id' => NULL
        ),
      'file' => 'dynamic_persistent_menu.theme.inc', 
    ),
    // The settings list.
    'dynamic_persistent_menu_settings_list' => array(
      'arguments' => array('menus' => array()),
    ),
  );
}

/**
 * Callback function to define settings of one particular menu, or a new one.
 */
function dynamic_persistent_menu_setting_base_form($dpm = NULL) {
  $options = menu_parent_options(menu_get_menus(), array('mlid' => 0));
  $form['dpmid'] = array(
    '#type' => 'hidden',
    '#value' => (isset($dpm->dpmid) ? $dpm->dpmid : NULL)
  );
  $form['root'] = array(
    '#type' => 'select',
    '#title' => t('Menu root'),
    '#default_value' => (isset($dpm->root) ? $dpm->root : 0),
    '#options' => $options,
    '#description' => t('Choose the menu you wish to display in the block')
  );
  $form['timeout'] = array(
    '#type' => 'textfield',
    '#title' => t('Sub-menu timeout'),
    '#default_value' => (isset($dpm->timeout)?$dpm->timeout:0),
    '#description' => t('Time before menu hiding when the mouse pointer leaves the parent menu (in milliseconds)')
  );
  return $form;
}

/**
 * @return
 * an object with the properties 
 *  - dpmid: an id for this dynamic menu, unique for this website.
 *  - root: the root menu item for this menu.
 *  - timeout: the timeout in miliseconds for this menu.
 */
function dynamic_persistent_menu_load($dpmid) {
  return db_query('SELECT dpmid, root, timeout FROM {dynamic_persistent_menu} WHERE dpmid = :dpmid', array(':dpmid' => $dpmid))->fetchObject();
}

/**
 * @dpmid
 *  - an id for this dynamic menu, unique to this website.
 */
function dynamic_persistent_menu_delete($dpmid) {
  db_delete('dynamic_persistent_menu')
  ->condition('dpmid', $dpmid)
  ->execute();
}

/**
 * Get the data structure representing a named menu tree, based on the current page.
 *
 * The tree order is maintained by storing each parent in an individual
 * field, see http://drupal.org/node/141866 for more.
 *
 * @param $menu_name
 *   The named menu links to return
 * @return
 *   An array of menu links, in the order they should be rendered. The array
 *   is a list of associative arrays -- these have two keys, link and below.
 *   link is a menu item, ready for theming as a link. Below represents the
 *   submenu below the link if there is one, and it is a subtree that has the
 *   same structure described for the top-level array.
 */
function dynamic_persistent_menu_tree_page_data($menu_name, $mlid) {
  static $tree = array();
  // #D7UP $cid is never defined
  $cid = '';
  // Load the menu item corresponding to the current page.
  if ($item = menu_get_item()) {
    if (!isset($tree[$cid])) {
      // If the static variable doesn't have the data, check {cache_menu}.
      // note that code is just copy pasted from the core menu.module
      $cache = cache('menu')->get($cid);

      // If the tree data was not in the cache, $data will be NULL.
      if (!isset($cache->data)) {
        // Build and run the query, and build the tree.
        if ($item['access']) {
          // Check whether a menu link exists that corresponds to the current path.
          $args = array($item['href']);
          
          if (drupal_is_front_page()) {
            $args[] = '<front>';
          }
          // TODO Please convert this statement to the D7 database API syntax.
          $parents = db_query("SELECT p1, p2, p3, p4, p5, p6, p7, p8 FROM {menu_links}
            WHERE menu_name = :menu_name AND link_path IN (:args)",
            array(':menu_name' => $menu_name, ':args' => $args))->fetchAssoc();

          if (empty($parents)) {
            // If no link exists, we may be on a local task that's not in the links.
            // TODO: Handle the case like a local task on a specific node in the menu.
            $parents = db_query("SELECT p1, p2, p3, p4, p5, p6, p7, p8 FROM {menu_links}
              WHERE menu_name = :menu_name AND link_path = :link_path",
              array(':menu_name' => $menu_name, ':link_path' => $item['tab_root']))->fetchAssoc();
          }

          // We always want all the top-level links with plid == 0.
          $parents[] = '0';
          // Use array_values() so that the indices are numeric for array_merge().

          $args = array($mlid);

          for ($i = 0; $i < 2; $i++) {
            $result = db_query("SELECT * FROM {menu_links} WHERE plid in (:args)", array(':args' => $args));

            foreach ($result as $row) {
              $args[] = $row->mlid;
            }
          }

          array_shift($args);
        }
        else {
          // Show only the top-level menu items when access is denied.
          $args = array(0);
          $parents = array();
        }

        // Select the links from the table, and recursively build the tree. We
        // LEFT JOIN since there is no match in {menu_router} for an external
        // link.
        $i = 0;
        $args_array_inner = array();
        $args_array_assoc = array();
        foreach ($args as $arg) {
          $args_array_inner[$i] = ':arg_' . $i;
          $args_array_assoc[$args_array_inner[$i]] = $arg;
          $i++;
        }
        $args_array_assoc[':menu_name'] = $menu_name;
        if (!count($args)) {
          return array();
        }
        $result = db_query('
          SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, m.description, ml.*
          FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path
          WHERE ml.menu_name = :menu_name AND ml.mlid IN (' . implode(', ', $args_array_inner) . ')
          ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC', $args_array_assoc);
        $list = array();
        foreach ($result as $item) {
          $list[] = (array) $item;
        }
        
        $data['tree'] = menu_tree_data($list, $parents);
        $data['node_links'] = array();
        menu_tree_collect_node_links($data['tree'], $data['node_links']);
      }
      // Check access for the current user to each item in the tree.
      menu_tree_check_access($data['tree'], $data['node_links']);
      $tree = $data['tree'];
    }

    return $tree;
  }

  return array();
}
