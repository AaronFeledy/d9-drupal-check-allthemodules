/**
* DO NOT EDIT THIS FILE.
* THIS FILE IS COMPILED AUTOMATICALLY FROM ITS ES6 SOURCE.
* @preserve
**/'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function (Drupal) {
  'use strict';

  var AsyncQueue = function () {
    function AsyncQueue(obj, callback) {
      _classCallCheck(this, AsyncQueue);

      this.callback = callback;
      this.errors = [];
      this.errorCallbacks = [];
      this.object = obj;
      this.processed = [];
    }

    _createClass(AsyncQueue, [{
      key: 'destroy',
      value: function destroy() {
        this.callback = null;
        this.errors = [];
        this.errorCallbacks = [];
        this.object = null;
        this.processed = [];
        return this;
      }
    }, {
      key: 'error',
      value: function error(callback) {
        this.errorCallbacks.push(callback);
        return this;
      }
    }, {
      key: 'getErrors',
      value: function getErrors(reset) {
        var errors = [].concat(_toConsumableArray(this.errors));
        if (reset === undefined || reset) {
          this.errors = [];
        }
        return errors;
      }
    }, {
      key: 'getItems',
      value: function getItems() {
        var obj = this.object;

        if (typeof obj === 'function') {
          obj = obj();
        }

        if (Array.isArray(obj)) {
          return obj.reduce(function (o, v, k) {
            o[k] = v;
            return o;
          }, {});
        }

        return obj;
      }
    }, {
      key: 'getNextItem',
      value: function getNextItem() {
        var items = this.getItems();

        if (typeof items === 'function') {
          items.__asyncQueueId__ = items.name || items.constructor.name || 'anonymous function';
          return items;
        }

        var itemKeys = Object.keys(items);
        for (var i = 0, l = itemKeys.length; i < l; i++) {
          var key = itemKeys[i];
          if (this.processed.indexOf(key) === -1) {
            var item = items[key];
            item.__asyncQueueId__ = key;
            return item;
          }
        }
      }
    }, {
      key: 'process',
      value: function process() {
        var _this = this;

        var item = this.getNextItem();

        var done = function done() {
          _this.processed = [];
          var errors = _this.getErrors();
          if (errors[0]) {
            _this.errorCallbacks.forEach(function (callback) {
              return callback(errors);
            });
          }
          return _this;
        };

        if (!item) {
          return done();
        }

        var fn = void 0;
        var method = void 0;

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var originalArgs = [].concat(args);
        if (typeof item === 'function') {
          fn = item;
        } else if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
          method = args.shift();
          if (typeof method !== 'string') {
            this.errors.push(new Error(Drupal.t('The item being processed is an object. The first argument passed to AsyncQueue.process() must be a stringed method name to invoke on the item: @method', {
              '@method': method
            })));
            return done();
          }
          fn = item[method];
        }

        var async = false;

        var complete = function complete(success) {
          var error = null;

          if (typeof _this.callback === 'function') {
            success = _this.callback.call(item, success);
          }

          if (success === false) {
            error = new Error(Drupal.t('The processed item "@id" failed.', {
              '@id': item.__asyncQueueId__
            }));
          } else if (success instanceof Error || {}.toString.call(success) === '[object Error]') {
              error = success;
              success = false;
            } else {
                success = true;
              }

          if (!success && error) {
            _this.errors.push(error);
          }

          delete item.async;

          if (item.__asyncQueueAsync__ !== undefined) {
            item.async = item.__asyncQueueAsync__;
          }

          _this.processed.push(item.__asyncQueueId__);

          delete item.__asyncQueueAsync__;
          delete item.__asyncQueueId__;
          delete item.__asyncQueueMethod__;
          delete item.__asyncQueueArguments__;

          Drupal.tick(function () {
            return _this.process.apply(_this, _toConsumableArray(originalArgs));
          });
        };

        item.__asyncQueueAsync__ = item.async;
        item.__asyncQueueMethod__ = method;
        item.__asyncQueueArguments__ = args;

        item.async = function () {
          async = true;
          var once = 0;
          return function (success) {
            if (once === 0) {
              once = 1;
              Drupal.tick(function () {
                return complete(success);
              });
            }
          };
        };

        try {
          var success = void 0;
          if (typeof fn === 'function') {
            success = fn.apply(item, args);
          }
          if (!async) {
            complete(success);
          }
        } catch (err) {
          complete(err);
        }
      }
    }], [{
      key: 'create',
      value: function create(obj, callback) {
        return new this(obj, callback);
      }
    }]);

    return AsyncQueue;
  }();

  Drupal.AsyncQueue = AsyncQueue;
})(window.Drupal);