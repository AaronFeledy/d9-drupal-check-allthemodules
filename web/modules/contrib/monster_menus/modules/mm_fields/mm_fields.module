<?php

/**
 * @file
 * Field functions for Monster Menus
 */

use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\FieldStorageConfigInterface;
use Drupal\mm_fields\Plugin\Field\FieldWidget\MMFieldWidgetBase;

/**
 * Implements hook_form_FORM_ID_alter() for 'field_storage_config_edit_form'.
 *
 * Hide the cardinality form field, since this is handled differently in our
 * widgets.
 */
function mm_fields_form_field_storage_config_edit_form_alter(&$form, FormStateInterface $form_state) {
  // Verify that this is one of our widgets. If so, hide the cardinality fields.
  // I wish there was an easier way of doing this!
  if (isset($form['cardinality_container']) && in_array(\Drupal::service('plugin.manager.field.widget')->getInstance(array('field_definition' => $form_state->getStorage()['field_config']->getItemDefinition()->getFieldDefinition()))->getPluginId(), MMFieldWidgetBase::widgetTypes())) {
    $form['cardinality_container']['cardinality']['#default_value'] = FieldStorageDefinitionInterface::CARDINALITY_UNLIMITED;
    $form['cardinality_container']['#access'] = FALSE;
  }
}

/**
 * Implements hook_field_views_data().
 */
function mm_fields_field_views_data(FieldStorageConfigInterface $field) {
  $data = views_field_default_views_data($field);
  foreach ($data as $table_name => $table_data) {
    foreach ($table_data as $field_name => $field_data) {
      if (isset($field_data['filter']) && $field_name != 'delta') {
        // Filter: swap the handler to the 'in' operator.
        $data[$table_name][$field_name]['filter']['id'] = 'many_to_one';
      }
    }

    if ($field->getType() == 'mm_catlist') {
      // Relationship: add a relationship for related MM page.
      $field_name = $field->getName() . '_' . $field->getMainPropertyName();
      $data[$table_name][$field_name]['relationship'] = array(
        'base' => 'node_field_data',
        'base field' => 'nid',
        'label' => t('Nodes on pages'),
        'id' => 'sequential_join',
        'joins' => [
          [
            'left table' => $table_name,
            'left field' => $field_name,
            'table' => 'mm_node2tree',
            'field' => 'mmtid',
          ],
          [
            'left field' => 'nid',
            'table' => 'node_field_data',
            'field' => 'nid',
          ],
        ],
      );
    }
  }
  return $data;
}

/**
 * Implements hook_entity_bundle_field_info_alter().
 *
 * Look for instances of this module's fields and force the cardinality to
 * "unlimited".
 */
function mm_fields_entity_bundle_field_info_alter(&$fields) {
  /** @var FieldConfig $field_config */
  foreach ($fields as $field_name => $field_config) {
    $storage = $field_config->getFieldStorageDefinition();
    if (in_array($storage->getType(), MMFieldWidgetBase::widgetTypes()) && $storage->getCardinality() != FieldStorageDefinitionInterface::CARDINALITY_UNLIMITED) {
      $storage->setCardinality(FieldStorageDefinitionInterface::CARDINALITY_UNLIMITED);
      $storage->save();
    }
  }
}
