<?php

/**
 * @file
 * Entity access role module file.
 */

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Entity\FieldableEntityInterface;

/**
 * Implements hook_entity_access().
 */
function entity_access_by_role_entity_access(EntityInterface $entity, $operation, AccountInterface $account) {

  // Ensure the entity type is fieldable.
  if (!$entity->getEntityType()
    ->entityClassImplements(FieldableEntityInterface::class)) {
    return AccessResult::neutral();
  }

  // Paragraphs seem to run this access check even as user 1, so return neutral
  // if user 1.
  if ($account->id() == 1) {
    return AccessResult::allowed();
  }

  // We're only checking for view operations. Bail if otherwise.
  if ($operation != "view") {
    return AccessResult::neutral();
  }

  return entity_access_by_role_check_access($entity, $account);

}

/**
 * Checks "role_access" field of an entity and compares with user roles.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity to check.
 * @param \Drupal\Core\Session\AccountInterface $account
 *   The account to check.
 *
 * @return \Drupal\Core\Access\AccessResultAllowed|\Drupal\Core\Access\AccessResultForbidden|\Drupal\Core\Access\AccessResultNeutral
 *   The access result.
 */
function entity_access_by_role_check_access(EntityInterface $entity, AccountInterface $account) {

  // Create an array of any role_access fields.
  $roleAccessFields = array_filter($entity->getFieldDefinitions(), function ($fieldDefinition) {

    if ($fieldDefinition->getType() == "role_access") {
      return $fieldDefinition;
    }
  });

  // If there are no fields on the entity, we're not bothered.
  if (empty($roleAccessFields)) {
    AccessResult::neutral();
  }

  // Loop through any instances of the field and grab the values.
  foreach ($roleAccessFields as $roleAccessfieldDefinition) {

    $userHasAwaysAllowedRole = entity_access_by_role_user_has_an_always_allowed_role($account, $roleAccessfieldDefinition);

    if ($userHasAwaysAllowedRole) {
      return AccessResult::neutral();
    }

    // Check the value against the current user.
    $roleAccessFieldName = $roleAccessfieldDefinition->getName();
    $roleAccessValues = $entity->$roleAccessFieldName->getValue();


    // If there are no values, field is available but nothing selected,
    // we're not bothered.
    if (empty($roleAccessValues)) {
      return AccessResult::neutral();
    }

    // Create a flat array of the role_access field values.
    $roleAccessValues = array_map(function ($valueArray) {

      return $valueArray['value'];
    }, $roleAccessValues);
    // If there are no matches between arrays, forbid.
    // Included account id == 1 as User 1 was unable to view paragraphs.
    if (!array_intersect($roleAccessValues, $account->getRoles())) {
      return AccessResult::forbidden();
    }
    return AccessResult::neutral();

  }
}

/**
 * @param \Drupal\Core\Session\AccountInterface $account
 * @param $roleAccessfieldDefinition
 *
 * @return array
 */
function entity_access_by_role_user_has_an_always_allowed_role(AccountInterface $account, $roleAccessfieldDefinition) {

  $alwaysAllowedRoles = entity_access_by_role_get_always_allowed_roles($roleAccessfieldDefinition);
  $userHasAwaysAllowedRole = array_intersect(array_flip($alwaysAllowedRoles, $account->getRoles()));
  return $userHasAwaysAllowedRole;
}

/**
 * Returns an array of roles without the permission 'bypass node access'.
 *
 * @return array
 *   The array of roles.
 */
function entity_access_by_role_roles_without_bypass_access() {

  return array_diff(user_role_names(FALSE), user_role_names(FALSE, 'bypass node access'));
}

/**
 * Get the always allowed role setting from the field.
 *
 * @param $definition
 *   The field definition
 *
 * @return array
 *   An array of always allowed roles.
 *
 */
function entity_access_by_role_get_always_allowed_roles($definition) {

  $alwaysAllowedValues = $definition->getSetting("always_allowed");

  if (empty($alwaysAllowedValues)) {
    return [];
  }

  $alwaysAllowed = array_filter($alwaysAllowedValues, function ($role) {

    return !empty($role);
  });

  return $alwaysAllowed;
}