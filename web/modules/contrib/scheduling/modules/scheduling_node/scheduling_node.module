<?php

use Drupal\Core\Entity\DynamicallyFieldableEntityStorageInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\StringTranslation\TranslatableMarkup;
use Drupal\entity\BundleFieldDefinition;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\node\NodeTypeInterface;
use Drupal\scheduling\Plugin\Field\FieldWidget\SchedulingValueWidget;

function scheduling_node_entity_bundle_field_info(
  EntityTypeInterface $entity_type,
  $bundle,
  $fields
) {
  /** @var \Drupal\Core\Config\ImmutableConfig $settings */
  if ($entity_type->id() === 'node' && $settings = \Drupal::service('config.factory')->get('scheduling.settings')) {
    if (in_array($entity_type->id(), array_keys($settings->get('entity_types')), TRUE) &&
        in_array($bundle, array_keys($settings->get('bundles.' . $entity_type->id())), TRUE) &&
        empty($fields[$settings->get('field_name')]) &&
        $settings->get('bundles.' . $entity_type->id() . '.' . $bundle) !== 'inactive') {

      $field_name = $settings->get('field_name') ? $settings->get('field_name') : 'scheduling';
      $field_label = $settings->get('label') ? $settings->get('label') : 'Scheduling';

      // Add the scheduling field to the bundle's field definitions.
      $fields[$field_name . '_' . MODE_FIELD_SUFFIX] = BundleFieldDefinition::create('scheduling_mode')
        ->setRequired(TRUE)
        ->setName($field_name . '_' . MODE_FIELD_SUFFIX)
        ->setLabel(new TranslatableMarkup($field_label))
        ->setDisplayOptions('form', [
          'type' => 'scheduling_mode',
          'weight' => 190,
        ])
        ->setSetting('mode', $settings->get('bundles.' . $entity_type->id() . '.' . $bundle) ? $settings->get('bundles.' . $entity_type->id() . '.' . $bundle) : SchedulingValueWidget::defaultSettings()['mode'])
        ->setDefaultValue('unpublished')
        ->setCardinality(1);

      // Add the scheduling field to the bundle's field definitions.
      $fields[$field_name . '_' . VALUE_FIELD_SUFFIX] = BundleFieldDefinition::create('scheduling_value')
        ->setName($field_name . '_' . VALUE_FIELD_SUFFIX)
        ->setLabel(new TranslatableMarkup($field_label))
        ->setClass('\Drupal\Core\Field\MapFieldItemList')
        ->setDisplayOptions('form', [
          'type' => 'scheduling_value',
          'weight' => 195,
          'settings' => [
            'mode' => $settings->get('bundles.' . $entity_type->id() . '.' . $bundle) ? $settings->get('bundles.' . $entity_type->id() . '.' . $bundle) : SchedulingValueWidget::defaultSettings()['mode'],
          ],
        ])
        ->setCardinality(BaseFieldDefinition::CARDINALITY_UNLIMITED);

    }
  }
  return $fields;
}

/**
 * Implements hook_entity_field_storage_info().
 */
function scheduling_node_entity_field_storage_info(
  \Drupal\Core\Entity\EntityTypeInterface $entity_type
) {
  /** @var \Drupal\Core\Config\ImmutableConfig $settings */
  if ($entity_type->id() === 'node' && $settings = \Drupal::service('config.factory')->get('scheduling.settings')) {
    if (in_array($entity_type->id(), array_keys($settings->get('entity_types')), TRUE) && count($settings->get('bundles.' . $entity_type->id())) > 0) {
      if (\Drupal::service('entity_type.manager')->getStorage($entity_type->id()) instanceof DynamicallyFieldableEntityStorageInterface) {
        // Query by filtering on the ID as this is more efficient than filtering
        // on the entity_type property directly.
        $ids = \Drupal::entityQuery('field_storage_config')
          ->condition('id', $entity_type->id() . '.', 'STARTS_WITH')
          ->execute();

        // Fetch all fields and key them by field name.
        $field_storages = FieldStorageConfig::loadMultiple($ids);
        $fields = [];
        foreach ($field_storages as $field_storage) {
          $fields[$field_storage->getName()] = $field_storage;
        }

        $field_name = $settings->get('field_name') ? $settings->get('field_name') : 'scheduling';

        $fields[$field_name . '_' . MODE_FIELD_SUFFIX] = FieldStorageConfig::create([
          'id' => 'node.' . $field_name . '.' . MODE_FIELD_SUFFIX,
          'entity_type' => 'node',
          'field_name' => $field_name . '_' . MODE_FIELD_SUFFIX,
          'type' => 'scheduling_mode',
          'cardinality' => -1,
          'translatable' => TRUE,
          'module' => 'scheduling_node',
        ]);

        $fields[$field_name . '_' . VALUE_FIELD_SUFFIX] = FieldStorageConfig::create([
          'id' => 'node.' . $field_name . '.' . VALUE_FIELD_SUFFIX,
          'entity_type' => 'node',
          'field_name' => $field_name . '_' . VALUE_FIELD_SUFFIX,
          'type' => 'scheduling_value',
          'cardinality' => -1,
          'translatable' => TRUE,
          'module' => 'scheduling_node',
        ]);

        return $fields;
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for \Drupal\node\NodeTypeForm.
 */
function scheduling_node_form_node_type_form_alter(
  &$form,
  FormStateInterface $form_state
) {
  /** @var \Drupal\node\NodeTypeInterface $type */
  $type = $form_state->getFormObject()->getEntity();
  /** @var \Drupal\Core\Config\ImmutableConfig $settings */
  $settings = \Drupal::service('config.factory')->get('scheduling.settings');
  $form['scheduling'] = [
    '#type' => 'details',
    '#title' => new TranslatableMarkup('Scheduling settings'),
    '#group' => 'additional_settings',
  ];
  $form['scheduling']['scheduling_mode'] = [
    '#type' => 'select',
    '#title' => new TranslatableMarkup('Scheduling mode'),
    '#default_value' => $settings->get('bundles.node.' . $type->id()) ?: 'inactive',
    '#options' => [
      'inactive' => new TranslatableMarkup('Inactive'),
      'range' => new TranslatableMarkup('Range'),
      'recurring' => new TranslatableMarkup('Recurring'),
      'combined' => new TranslatableMarkup('Combined'),
    ],
    '#description' => t('Choose the scheduling mode for this content type.'),
  ];
  $form['#entity_builders'][] = 'scheduling_node_form_node_type_form_builder';
}

/**
 * Add scheduling configuration to content/node type/bundle edit form.
 *
 * @see menu_ui_form_node_type_form_alter()
 */
function scheduling_node_form_node_type_form_builder(
  $entity_type,
  NodeTypeInterface $type,
  &$form,
  FormStateInterface $form_state
) {
  $mode = $form_state->getValue('scheduling_mode');
  /** @var \Drupal\Core\Config\Config $settings */
  $settings = \Drupal::service('config.factory')->getEditable('scheduling.settings');
  if (!$mode || $mode !== 'inactive') {
    $settings->set('bundles.node.' . $type->id(), $form_state->getValue('scheduling_mode'));
  } else {
    $settings->clear('bundles.node.' . $type->id());
  }
  $entity_types = $settings->get('entity_types');
  // Add node entity type to entity_type list if appropriate.
  if (count($settings->get('bundles.node') > 0) && !in_array('node', $entity_types, TRUE)) {
    $entity_types['node'] = 'node';
    $settings->set('entity_types', $entity_types);
  }
  // Remove enitty type from entity_type list if apprpriate.
  if (count($settings->get('bundles.node')) <= 0 && in_array('node', $entity_types, TRUE)) {
    unset($entity_types['node']);
    $settings->set('entity_types', $entity_types);
  }
  $settings->save();
  \Drupal::service('entity_type.manager')->clearCachedDefinitions();
  \Drupal::service('entity.definition_update_manager')->applyUpdates();
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for \Drupal\node\NodeForm.
 *
 * Changes vertical tabs to container.
 */
function scheduling_node_form_node_form_alter(&$form, FormStateInterface $form_state) {
  $bundle = $form_state->getFormObject()->getEntity()->bundle();
  /** @var \Drupal\Core\Config\ImmutableConfig $settings */
  if ($settings = \Drupal::service('config.factory')->get('scheduling_node.settings')) {
    if ('node' === $settings->get('entity_type') &&
      in_array($bundle, array_keys($settings->get('bundles')), TRUE) &&
      empty($fields[$settings->get('field_name')]) &&
      $settings->get('bundles.' . $bundle) !== 'inactive') {

      if (isset($form['status'])) {
        $form['status']['#access'] = FALSE;
      }

    }
  }

}
