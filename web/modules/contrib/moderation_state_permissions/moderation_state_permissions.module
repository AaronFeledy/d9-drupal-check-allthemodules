<?php

/**
 * @file
 * Contains moderation_state_permissions.module.
 */

use Drupal\moderation_state_permissions\PermissionsGenerator;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Routing\RouteMatchInterface;

/**
 * Implements hook_help().
 */
function moderation_state_permissions_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the moderation_state_permissions module.
    case 'help.page.moderation_state_permissions':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Adds entity edit permissions based on their moderation states.') . '</p>';
      return $output;

    default:
  }
}

/**
 * Implements hook_entity_access().
 */
function moderation_state_permissions_entity_access(\Drupal\Core\Entity\EntityInterface $entity, $operation, \Drupal\Core\Session\AccountInterface $account) {
  /** @var \Drupal\content_moderation\ModerationInformationInterface $moderationInformation */
  $moderationInformation = \Drupal::service('content_moderation.moderation_information');
  if ($moderationInformation->isModeratedEntity($entity) && in_array($operation, PermissionsGenerator::$OPERATIONS)) {
    assert($entity instanceof ContentEntityInterface);
    $workflow = $moderationInformation->getWorkflowForEntity($entity);
    $state = $entity->moderation_state->value ? $workflow->getTypePlugin()->getState($entity->moderation_state->value) : $workflow->getTypePlugin()->getInitialState($entity);
    $permission = PermissionsGenerator::getPermissionName($operation, $workflow->id(), $state->id());
    return AccessResult::forbiddenIf(
      !$account->hasPermission($permission),
      "The '$permission' permission is required."
    )->addCacheContexts(['user.permissions']);
  }
  return AccessResult::neutral();
}
