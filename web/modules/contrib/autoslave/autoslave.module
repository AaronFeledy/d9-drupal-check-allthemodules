<?php

use Drupal\Core\Database\Database;

include_once('lib/Drupal/autoslave/Database/Driver/autoslave/defines.inc');

/**
 * Implements hook_menu().
 */
function autoslave_menu() {
  $items = array();
  $items['admin/config/system/autoslave'] = array(
    'title' => 'AutoSlave',
    'description' => 'AutoSlave settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('autoslave_settings_form'),
    'access arguments' => array('administer site configuration'),
  );
  $items['admin/config/system/autoslave/settings'] = array(
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'title' => 'Settings',
    'weight' => 1,
  );
  $items['admin/config/system/autoslave/status'] = array(
    'title' => 'Status',
    'description' => 'AutoSlave status',
    'page callback' => 'autoslave_status_page',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK
  );
  $items['admin/config/system/autoslave/affected-tables'] = array(
    'title' => 'Affected tables',
    'description' => 'AutoSlave affected tables',
    'page callback' => 'autoslave_affected_tables_page',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK
  );
  return $items;
}

/**
 * Settings form
 */
function autoslave_settings_form() {
  if (!autoslave_is_driver_loaded()) {
    drupal_set_message(t('AutoSlave driver is not loaded'), 'warning');
  }
  $form['help'] = array(
    '#markup' => 'More help to come ...',
  );
  return system_settings_form($form);
}

/**
 * Status page for all autoslave setups
 */
function autoslave_status_page() {
  if (!autoslave_is_driver_loaded()) {
    drupal_set_message(t('AutoSlave driver is not loaded'), 'warning');
    return '';
  }

  // Load .install files
  include_once DRUPAL_ROOT . '/core/includes/install.inc';
  $tasks = db_installer_object('autoslave');

  global $databases;
  $output = '';
  foreach ($databases as $key => $targets) {
    foreach ($targets as $target => $conninfo) {
      $conninfos = empty($conninfo['driver']) ? $conninfo : array($conninfo);
      foreach ($conninfos as $conninfo) {
        if ($conninfo['driver'] != 'autoslave') {
          continue;
        }
        $output .= "<h2>[$key][$target]</h2>";
        $output .= $tasks->connectionStatusTable(Database::getConnection($target, $key));
        $output .= '<br>';
      }
    }
  }

  return $output;
}

/**
 * Status page for the affected tables
 */
function autoslave_affected_tables_page() {
  if (!autoslave_is_driver_loaded()) {
    drupal_set_message(t('AutoSlave driver is not loaded'), 'warning');
  }

  $active = array();
  $inactive = array();
  $connection = Database::getConnection();
  $target = $connection->driver() === 'autoslave' ? $connection->determineSystemTarget() : NULL;
  $query = db_select('autoslave_affected_tables', 'a', array('target' => $target))
             ->fields('a', array('db_key', 'db_target', 'affected_table', 'expires'))
             ->orderBy('a.expires', 'DESC')
             ->execute()
             ->fetchAll(PDO::FETCH_ASSOC);


  foreach ($query as $row) {
    if ($row['expires'] > $_SERVER['REQUEST_TIME']) {
      $row['expires'] = date('Y-m-d H:i:s', $row['expires']);
      $active[] = $row;
    }
    else {
      $row['expires'] = date('Y-m-d H:i:s', $row['expires']);
      $inactive[] = $row;
    }
  }

  $output = '';
  $header = array('Key', 'Target', 'Table', 'Expires');
  $output .= "<h2>Active</h2>";
  $output .= theme('table', array('header' => $header, 'rows' => $active));
  $output .= '<br>';
  $output .= "<h2>Inactive</h2>";
  $output .= theme('table', array('header' => $header, 'rows' => $inactive));

  return $output;
}


/**
 * Implements hook_cron().
 * Check invalidated connections and update their status.
 */
function autoslave_cron() {
  global $databases;
  foreach ($databases as $key => $targets) {
    foreach ($targets as $target => $conninfo) {
      $conninfos = empty($conninfo['driver']) ? $conninfo : array($conninfo);
      foreach ($conninfos as $conninfo) {
        if ($conninfo['driver'] != 'autoslave') {
          continue;
        }
        $conn = Database::getConnection($target, $key);
        if ($conn->driver() != 'autoslave') {
          continue;
        }

        $pool = $conn->getPool();
        foreach ($pool['all'] as $id => $conninfo) {
          if ($conninfo['driver'] == 'autoslave') {
            continue;
          }
          if (isset($conninfo['status']) && $conninfo['status'] === FALSE) {
            $status = $conn->checkConnection($id);
            $dsn = $conninfo['driver'] . '://' . $conninfo['host'];
            if ($status === TRUE || $status === FALSE) {
              watchdog('autoslave', "!dsn is up again!", array('!dsn' => $dsn), WATCHDOG_NOTICE);
              $conn->updateInvalidationFile($conninfo['key'], $conninfo['target'], $conninfo['idx'], TRUE);
            }
            else {
              watchdog('autoslave', "!dsn is still down: !status", array('!dsn' => $dsn, '!status' => $status->getMessage()), WATCHDOG_ERROR);
            }
          }
        }
      }
    }
  }
}

function autoslave_is_driver_loaded() {
  return Database::getConnection('default', 'default')->driver() === 'autoslave';
}

/**
 * Implements hook_batch_alter().
 *
 * SimpleTest renames/copies the default connection. This will fail with the AutoSlave
 * driver. If a simpletest is about to run switch very hard to the master!
 */
function autoslave_batch_alter(&$batch) {
  // It's not necessary to do anything, if AutoSlave driver is not loaded
  if (!autoslave_is_driver_loaded()) {
    return;
  }

  // Make sure we wrap the simpletest batch operation, so that we may
  // switch to the master permanently
  foreach ($batch['sets'] as &$set) {
    if (!empty($set['operations'])) {
      foreach ($set['operations'] as &$operation) {
        // This is a simpletest batch operation. Hijack it, so that
        // we may perform a hard switch to the master before it runs.
        if ($operation[0] == '_simpletest_batch_operation') {
          $operation = array('_autoslave_batch_operation', $operation);
        } 
      }
    }
  }
}

/**
 * Wrapper for simpletest batch operations.
 * Make sure that the master is defined as the 'default' target, otherwise
 * simpletest won't make it ...
 */
function _autoslave_batch_operation($callback, $args, &$context) {
  $connection = Database::getConnection();
  if ($connection->driver() == 'autoslave') {
    $connection->hardSwitch();
  }
  $args[] = &$context;
  call_user_func_array($callback, $args);
}

/**
 * Implements hook_query_TAG_alter().
 */
function autoslave_query_autoslave_alter($query) {
  if (!$query instanceOf SelectQuery) {
    return;
  }
  list($target, $key) = $query->getMetaData('autoslave_connection');
  $connection = Database::getConnection($target, $key);

  // Determine master/slave based on intersection of $this->getTables() and $connection->getAffectedTables()
  $tables = array();
  foreach ($query->getTables() as $tableinfo) {
    $tables[] = $tableinfo['table'];
  }
  $connection = array_intersect($tables, $connection->getAffectedTables()) ? $connection->getMasterConnection() : $connection->getSlaveConnection();

  AutoSlaveSelectQueryInjector::changeConnection($query, $connection);
}

/**
 * Implements hook_book().
 * Dummy implementation for ensuring early module load
 */
function autoslave_boot() {
}
