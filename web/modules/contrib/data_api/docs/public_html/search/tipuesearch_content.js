var tipuesearch = {"pages":[{"title":"Drupal Module: Data Common Api","text":"  Author: Aaron Klump  &#x73;&#111;&#117;&#x72;&#x63;&#101;c&#x6f;&#100;&#101;&#x40;&#x69;&#110;&#116;&#x68;&#x65;&#108;&#x6f;&#x66;&#116;&#115;&#x74;&#x75;&#100;i&#x6f;&#115;&#46;&#x63;&#x6f;&#109;  Summary  Provide a simple and consistent means to interact programatically with entity data, form submissions and other Drupal data across projects and major versions.  You may also visit the project page on Drupal.org.  Requirements   Php 5.3 or higher   Installation   Install as usual, see http:\/\/drupal.org\/node\/70151 for further information. If you are not using composer to manage your site, you must add this module's composer.json file to the root merge-plugin see this link for more info.   Configuration   No configuration is necessary; but the module won't do anything unless you utilitze it's functions.   Suggested Use  More code examples are available if you enable the Advanced Help module.  Read Entities  \/\/ Create a getter for node entities $n = data_api('node');  \/\/ Load a node entity $node = node_load(4503);  \/\/ Use the getter to pull the first name or default. \/\/ Do not include the language key; language is determined automatically. $vars['name'] = $n-&gt;get($node, 'field_first_name.0.value', '{first name}');  \/\/ You can resuse the node getter with a new node.  The node getter can be reused as long as the entity type doesn't change. $node = node_load(345); $vars['name'] = $n-&gt;get($node, 'field_first_name.0.value', '{first name}');  \/\/ But to pull data from a different entity type, you can either create a new getter for user entities... $u = data_api('user');  \/\/... or just reassign the entity type of the original getter to 'user'. $n-&gt;setEntityType('user'); $vars['mail'] = $n-&gt;get($GLOBALS['user'], 'mail', '{missing email}');   Set entities  \/\/ Load a comment entity $comment = comment_load(1);  \/\/ Change the body value in the object only. data_api('comment')-&gt;set($comment, 'comment_body.0.value', 'lorem', []);  \/\/ Save the comment to the database comment_save($comment);   Arrays and objects  This will also work on native arrays and objects, and offers a means of supplying defaults with minium code.  For more information go here.  \/\/ Create a global getter that uses no entity type. $g = data_api();  \/\/ Using a standard array... $array = array('do' =&gt; array('re', 'mi'));  \/\/ Access it's elements. print $g-&gt;get($array, 'do.0', 'none'); \/\/ === 're' print $g-&gt;get($array, 'do.1', 'none'); \/\/ === 'mi' print $g-&gt;get($array, 'do.2', 'none'); \/\/ === 'none'; the default  \/\/ Set a deep object $object = new \\stdClass; $g-&gt;set($object, 'do.re.mi.fa.so', 'laaaa');  ... $object-&gt;do-&gt;re-&gt;mi-&gt;fa-&gt;so === 'laaaa'   And form submissions...  $value = data_api()-&gt;get($form_state, 'values.summary', 'none');   Use callback to load an entity reference  The fourth argument is a callable that receives the value and the default, so you can post process the value, e.g.,  $related_node = data_api('node')-&gt;get($node, 'field_related_node.0.nid', null, function ($nid, $defaultValue) {     return $nid ? node_load($nid) : $defaultValue; });   Design Decisions\/Rationale   To bring consistency across Drupal versions for accessing data on entities. To simplify the code used to programatically interact with entities. To avoid Exceptions and issets() when pulling data.   Roadmap\/Drupal 8  I'm planning a Drupal 8 version which will follow the same patterns so you do not have to relearn a new api.  Contact   In the Loft Studios Aaron Klump - Developer PO Box 29294 Bellingham, WA 98228-1294 skype: intheloftstudios d.o: aklump http:\/\/www.InTheLoftStudios.com  ","tags":"","url":"README.html"},{"title":"Use Inside a Class","text":"   Whenever a class needs to use data_api(), you should use the trait DataApiTrait, instead. Then use DI to inject a Data object into the constructor. You should never call data_api() from inside a class (except for static methods, which are not fully tested yet, use at your own discretion.) Refer to the class documentation for implementation details.  &lt;?php class ClassThatNeedsADataObjectForItsMethods {    use \\Drupal\\data_api\\DataTrait;    public function __construct(Data $data) {     $this-&gt;setDataApiData($data);   } }  ...  \/\/ Use in production code $data = data_api(); $instance = new  ClassThatNeedsADataObjectForItsMethods($data);  ...   \/\/ Use in testing $data = new \\Drupal\\data_api\\DataMock(); $instance = new  ClassThatNeedsADataObjectForItsMethods($data);   ","tags":"","url":"data_api_trait.html"},{"title":"Summary","text":"  Provide a simple and consistent means to interact programatically with entity data, form submissions and other Drupal data across projects and major versions.  Requirements   Php 5.3 or higher   Installation   Install as usual, see http:\/\/drupal.org\/node\/70151 for further information.   Configuration   No configuration is necessary; but the module won't do anything unless you utilitze it's functions.   Suggested Use  More code examples are available if you enable the Advanced Help module.  Read Entities  \/\/ Create a getter for node entities $n = data_api('node');  \/\/ Load a node entity $node = node_load(4503);  \/\/ Use the getter to pull the first name or default. \/\/ Do not include the language key; language is determined automatically. $vars['name'] = $n-&gt;get($node, 'field_first_name.0.value', '{first name}');  \/\/ You can resuse the node getter with a new node.  The node getter can be reused as long as the entity type doesn't change. $node = node_load(345); $vars['name'] = $n-&gt;get($node, 'field_first_name.0.value', '{first name}');  \/\/ But to pull data from a different entity type, you can either create a new getter for user entities... $u = data_api('user');  \/\/... or just reassign the entity type of the original getter to 'user'. $n-&gt;setEntityType('user'); $vars['mail'] = $n-&gt;get($GLOBALS['user'], 'mail', '{missing email}');   Set entities  \/\/ Load a comment entity $comment = comment_load(1);  \/\/ Change the body value in the object only. data_api('comment')-&gt;set($comment, 'comment_body.0.value', 'lorem', []);  \/\/ Save the comment to the database comment_save($comment);   Arrays and objects  This will also work on native arrays and objects, and offers a means of supplying defaults with minium code.  For more information go here.  \/\/ Create a global getter that uses no entity type. $g = data_api();  \/\/ Using a standard array... $array = array('do' =&gt; array('re', 'mi'));  \/\/ Access it's elements. print $g-&gt;get($array, 'do.0', 'none'); \/\/ === 're' print $g-&gt;get($array, 'do.1', 'none'); \/\/ === 'mi' print $g-&gt;get($array, 'do.2', 'none'); \/\/ === 'none'; the default  \/\/ Set a deep object $object = new \\stdClass; $g-&gt;set($object, 'do.re.mi.fa.so', 'laaaa');  ... $object-&gt;do-&gt;re-&gt;mi-&gt;fa-&gt;so === 'laaaa'   And form submissions...  $value = data_api()-&gt;get($form_state, 'values.summary', 'none');   Use callback to load an entity reference  The fourth argument is a callable that receives the value and the default, so you can post process the value, e.g.,  $related_node = data_api('node')-&gt;get($node, 'field_related_node.0.nid', null, function ($nid, $defaultValue) {     return $nid ? node_load($nid) : $defaultValue; });   Design Decisions\/Rationale   To bring consistency across Drupal versions for accessing data on entities. To simplify the code used to programatically interact with entities. To avoid Exceptions and issets() when pulling data.   Roadmap\/Drupal 8  I'm planning a Drupal 8 version which will follow the same patterns so you do not have to relearn a new api. ","tags":"","url":"drupal-org.html"},{"title":"Return all products referenced by a node","text":"    $products = data_api('node')-&gt;get($node, 'field_product', array(), function ($items, $default) {       array_walk($items, function (&amp;$item) {           $item = commerce_product_load($item['product_id']);       });        return $items ? $items : $default;   });  ","tags":"","url":"examples--commerce.html"},{"title":"Taxonomy code examples","text":"  Example 1  Before  Without the use of data_api.  $item = taxonomy_term_load(123); $title = check_plain($item-&gt;name); if (!empty($item-&gt;field_edu_subject_short)) {     $title = field_view_value('taxonomy_term', $item, 'field_edu_subject_short', $item-&gt;field_edu_subject_short[$lang][0]);     $title = drupal_render($title); }   After  The above code is refactored like this:  $tt = data_api('taxonomy_term'); ... $item = taxonomy_term_load(123); $title = $tt-&gt;get($item, 'field_edu_subject_short.0', check_plain($item-&gt;name), function ($title) use ($item) {     $title = field_view_value('taxonomy_term', $item, 'field_edu_subject_short', $title);      return drupal_render($title); });   Example 2: Iteration  Before  if (!empty($item-&gt;field_edu_level)) {     foreach (array_keys($item-&gt;field_edu_level) as $lang) {         foreach ($item-&gt;field_edu_level[$lang] as $delta =&gt; $edu_level) {             ...         }     } }   After  Iterations become much simpler:  $tt = data_api('taxonomy_term'); ... foreach ($tt-&gt;get($item, 'field_edu_level', []) as $delta =&gt; $edu_level) {     ... }  ","tags":"","url":"examples--taxonomy.html"},{"title":"Testing with PhpUnit","text":"  If you are injecting a Drupal\\data_api\\Data object into a class that you're writing for your module.  You can do it in such a way that it will be unit testable.  Here's how:   Place the following at the top of your PhpUnit test file, or test suite bootstrap, so that data_api's autoload.php file is included in your tests.  Adjust the displayed path as needed.  require_once dirname(__FILE__) . '\/.....\/data_api\/tests\/bootstrap.php';  Then use the Drupal\\data_api\\DataMock object as the injection class.  It has been decoupled from Drupal and works fine in most normal circumstances.  You may need to extend it for you specific situation, but there should be enough to go on by looking at that class alone as to how to do that.  Here's a possible solution:  &lt;?php ...  use Drupal\\data_api\\DataMock;  \/**  * Provides to a base test for module unit tests.  *\/ class TestBase extends \\PHPUnit_Framework_TestCase {     public function setUp()     {         $this-&gt;dataApi = new DataMock;         this-&gt;myClass = new MyClass($this-&gt;dataApi);     } }    When Testing an Entity  Refer to the following test method:    public function testFVariationsWork($control, $default, $column, $delta) {     global $entity;     $entity = (object) [       'type' =&gt; 'page',       'field_summary' =&gt; [         'und' =&gt; [           0 =&gt; ['value' =&gt; 'lorem'],           1 =&gt; ['value' =&gt; 'ipsum'],         ],       ],     ];      ...    }   You must do the following:   global $entity Give `$entity->type' an arbitrary value.  ","tags":"","url":"phpunit.html"},{"title":"Search Results","text":" ","tags":"","url":"search--results.html"}]};
