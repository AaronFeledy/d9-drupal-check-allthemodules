<!DOCTYPE html>
<html>
<head>
    <title>Chunker Usage</title>
    <link rel="stylesheet" type="text/css" href="css/docs.css"/>
    <link rel="stylesheet" type="text/css" href="css/docbook.css"/>

</head>
<body>
<h1>Using chunker.module</h1>
<strong>.. to provide alternative ways of presenting large pages of text.</strong>

<p>
    We have a number of pages, managed with WYSIWYG by untrained editors.

    We want them to be able to easily divide the page into sections, and
    for those sections to then be presented and themed specially.
</p>

<p>
    This module lets you do this.
    It reformats the content in long text areas, adjusting the markup to
    break it into nested and classed sections, then applies layout techniques
    over top of that to improve presentation.
<p>

<h3>Examples</h3>
<p>
    To immediately try it out, a number of working examples are provided at
    <a href="/admin/help/chunker/examples">/admin/help/chunker/examples</a>
</p>

<h3>Semantic reformatting</h3>
<p>
    <i>Unlike Javascript-only document-rewriters</i>,
    this tool actually reformats the output markup.
    This means that anchors, search engines, browser history, accessibility,
    bookmarks, and other expectations about the web will continue to work!
    <i>On the other hand</i>, it does mean that there can be confusing
    differences between the markup entered in a WSYIWYG and the eventual result.
    Conflicts can exist, so take care.
</p>

<h2>Usage &amp; Theory</h2>
<p>
    To make chunking happen, just let the editors use H2, H3 tags to arrange
    their content,
    and the chunker system will intelligently use those cues
    to reformat the page.

    This can be enabled globally for all pages,
    or these alternate displays and the
    settings for them can be managed through "View Modes".

    Even further, using display_suite.module "view mode per node" an editor
    can choose between a few options provided by the site design.
</p>

<h3>The opposite of drag & drop field-based GUIs</h3>
<p>
    Unlike widget-based editing paradigms like <b>Paragraphs</b> or <b>Bricks</b> modules
    (where page content is constructed as a set of sub-components or individual elements),
    This module supports treating large sections of content primarily as native text or markup,
    (possibly with rich content elements embedded inside it)
    and adds visual structure automatically, after the user has done their editing.
    <br/>
    The intent of this approach is:
<ul>
    <li>To support rapid input of content from import sources - such as Paste-From-Word, or Feeds or Migrate import of
        existing, semi-structured free text.
    </li>
    <li>To support keyboard-literate content editors who can already use a Rich Text Editor proficiently,
        and don't want/need to use the mouse, extra select widgets, and drag & drop for content structuring each time
        they want to start a new 'section' of text.
    </li>
    <li>
        To take advantage of established WYSIWYG processes, such as Find-&-Replace-All, or Select-All-Copy-&-Paste,
        and the ability to split or merge or re-arrange paragraphs as a normal text editor would do.
    </li>
    <li>To continue to support meaningful 'diff' and revisions of largely textual changes.</li>
    <li>To support publishing workflows that need to be able to re-import over top of content from outside sources,
        whether by copy & paste or Import-from-Word.
        The challenges of re-pagination and manual re-structuring in a component-based workflow
        make re-importing over already-structured content a tricky task.
    </li>
    <li>To reduce the number of visual design choices a daily content editor is expected to make.
        By auto-formatting regular content in a regular way, content editors should be able to focus on the content.
        ... For more exotic, unique and creative layouts, different layout tools should be used.
    </li>
    <li>Future-proofing the internal data model of your content. See below.
    </li>
</ul>

<h4>Future-proofing the internal data model of content.</h4>
<p><em>Opinion:</em></p>
<p>
    While HTML-in-database may not be the perfect paradigm for long-term storage of your valuable content,
    it is superior to many-elements-in-many-database-fields-strung-together-with-unique-&-elaborate-relationships-determined-ad-hoc-by-the-visual-design.
    CMSs have come and gone, and will continue to come and go.
    Depending on the circumstances, it is likely that your clients content will one day have to be migrated out of
    the system you are putting it in to.
    It may need to be displayed in a device or format that is not the 3-column brick layout that the page layout
    elements currently provide.
    <br/>
    Consider the process that will have to happen if your website was valuable enough to still be running 10 years in the future.
    <br/>
    Chances are, the tools to be used to do that job in the future may <em>not</em> be the 2015 version of Drupals field layout API - but by some
    chump with a totally different language who can just reach far enough back into the past to use an SQL data extraction tool.
</p><p>
    If that legacy migration task can extract well-structured data from the body field in one query,
    your future migration path has the potential to be robust.
    If the data model they have to re-create from the DB, or even from the API <a href="https://matrix.squiz.net/manuals/concepts/chapters/page-contents-and-containers#Adding-a-New-container-to-a-Page">is significantly complicated</a>
    (to the point where it requires so much outdated domain-specific knowledge as to be virtually proprietary) ...
    the only reasonable migration path will be raw screen-scraping, and all the crud that will come with that.
</p><p>
    For this reason - because I don't hate the future "me"s (or the future robots) that will need to make sense of
    things - I believe that text-first is the more responsible long-term storage method
    <em><b>for content that is primarily prose</b></em>.
</p>



<h3>In-page Anchors</h3>
<p>
    The Chunker process will insert in-page anchor IDs to the sections it
    manages. These will be automatically derived from the nearest heading,
    so may be slightly volatile to editorial changes
    (however, still less volatile than auto-generated numeric ids).
    Editors can continue to create in-page anchors by assigning IDs to headings,
    manually, and these will be retained and used by preference, if detected.
</p>
<h3>Linking to in-page Anchors</h3>
<p>
    Some of the formatters will expose a 'permalink' next to headings
    (eg a subtle '#' symbol on hover), for easier bookmarking for users.
</p>
<h3>IDs refer to <em>sections</em> not just headings</h3>
<p>
    As a semantic feature, the anchor IDs are applied to the <em>section</em>
    of content they are identifying.
    We to not add empty, placeholder tags just for navigation,
    (<a href="http://tantek.com/log/2002/11.html#L20021128t1352">&lt;A&gt;norexic &lt;/A&gt;nchors</a>)
    nor do we target the heading alone if the <em>content</em>
    is what we intend to refer to.
    Targeting a full <em>section</em> is more contextually correct.
</p>
<h4>No H1s</h4>
<p>
    Though it's not completely prohibited, it is strongly recommended that
    your content does <em>not</em> use inline H1s.
    Semantically, there should only ever be one H1 per page (the title)
    and H1s inside body copy are likely to produce inconsistent results.
    The algorithms inside chunker assume that h2 is the first exected heading
    level.
</p>
<h4>Sensible heading use</h4>
<p>
    Real-world content comes in all flavours of "tag soup", and this module tries to make sense
    of that as intuatively as it can. Things work a lot better if your source content nests
    headings correctly, with H3 below H2, and H4 consistently being used only below H3, etc.
    However, Even if you do jump from H2 to H4, that should still be allowed without panic.
</p>

<h3>Content above headings</h3>

<p>Text content found before the first heading is generally expected to be intro text.
    In most formatting modes, that means it is not enwrapped in any section style, though a
    dedicated div may be added if needed. The option for that can be found in 'advanced' settings.</p>

<h2>Chunker Options</h2>
<p>
    Some of the layout options available just with tools already in Drupal core
    are: <em>(Each of these links should produce a working demo in action)</em>
</p>
<ul>
    <li><a href="/admin/help/chunker/examples/details">Collapsible sections</a> (HTML5 'details'</li>
    <li><a href="/admin/help/chunker/examples/horizontal_tabs">Horizontal tabs</a></li>
    <li><a href="/admin/help/chunker/examples/vertical_tabs">Vertical tabs</a></li>
</ul>
<p>
    We also provide a few extra presentations like:
</p>
<ul>
    <li>Visual <a href="/admin/help/chunker/examples/flat">flat boxing</a> or
        <a href="/admin/help/chunker/examples/nested">nested indentation</a>. (simple).
        Both of these slightly rewrite the markup to put wrappers around sections that could be styled,
        but add no extra behaviour. To see these in action, you may have to examine the markup directly,
        or enable the debugger (below) to see the results.
    </li>
    <li><a href="/admin/help/chunker/examples/teaser">In-page 'teasers'</a> to inline 'read-more' display
        of individual sections.
        (CSS-only enhancement)
    </li>
    <li><a href="/admin/help/chunker/examples/pager">Numeric pager</a>, with page numbers and 'previous/next' buttons.
        (javascript library plugin)
    </li>
</ul>


<h2>Example : Simple case</h2>
<ul>
    <li>
        Enable chunker.module.
        Requires: Libraries.
    </li>
    <li>
        Recommended : Enable a wysiwyg and configure it to support h2, h3 tags.
        <br/>
        As is usual with wysiwyg, disable the default line break filter.
        <small>
            WYSIWYG editing is not required, but it is the target use-case,
            and illustrates the power of Chunker best.
        </small>
    </li>
    <li>
        Ensure your text format lets H* tags and divs through. (use Full HTML)
    </li>
    <li>
        Create a 'Page' that makes liberal use of standard headings.
        <br/>
        However, ensure it's 'flat' (p,p,h2,p,p,h3,p,p,h2,p) as would be created
        if you just typed the content and used styles.
        and does not have a global wrapper or extra nesting around it (as may
        happen if you copy & paste complex HTML from the web)
    </li>
    <li>
        Visit
        <div class="guimenu">
            <em class="guimenuitem">Administration</em>
            <em class="guimenuitem">Structure</em>
            <em class="guimenuitem">Content types</em>
            <em class="guimenuitem">Page</em>
            <em class="guibutton">[Manage display]</em>
        </div>
    </li>
    <li>

        Edit the "Body" "Format"
    </li>
    <li>

        Expand the settings cog, and choose one of the 'chunk text' options.
    </li>
</ul>

<h2>Details</h2>
<h3>Dependencies</h3>
<p>
    The primary supported methods for applying the Chunker behaviour are through
    the Field UI, so the module works with that.
</p>

<p>
    However, similar processes can also be applied using Drupal text filters,
    which are closely related.
</p>

<p>As either or both of these methods can be used, the chunker module does not
    absolutely require either of them in the [dependencies] list. But nothing
    will happen unless you do have at least ONE of them.</p>

<h3>Debugging</h3>
<p>
    A quick, visual diagnostic tool can be enabled to help understand what
    is happening with your markup rewrites.
    Additional CSS styles will be added to the page to illustrate the div and
    section nestings.

    Set the Drupal variable <code>chunker_debuglevel</code> to true to enable it.
</p>
<pre>
    drush config-set chunker.settings chunker_debuglevel 1
    </pre>
or
<pre>
    // settings.php
    $config['chunker.settings']['chunker_debuglevel'] = 1;
    </pre>
<p>
    Set it to 0/FALSE again later to stop debugging.
    As this is developer-only, there is no UI for this.
</p>

</body>
</html>
