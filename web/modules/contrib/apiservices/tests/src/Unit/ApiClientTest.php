<?php

/**
 * @file
 * Contains \Drupal\Tests\apiservices\Unit\ApiClientTest.
 */

namespace Drupal\Tests\apiservices\Unit;

use Drupal\apiservices\ApiClient;
use Drupal\Tests\UnitTestCase;
use GuzzleHttp\Exception\RequestException;
use Prophecy\Argument;

/**
 * @coversDefaultClass \Drupal\apiservices\ApiClient
 * @group apiservices
 */
class ApiClientTest extends UnitTestCase {

  /**
   * The mock HTTP client.
   *
   * @var \GuzzleHttp\ClientInterface|\Prophecy\Prophecy\ProphecyInterface
   */
  protected $httpClient;
  
  /**
   * The mock cache backend.
   *
   * @var \Drupal\Core\Cache\CacheBackendInterface|\Prophecy\Prophecy\ProphecyInterface
   */
  protected $cache;

  /**
   * The mock logger.
   * 
   * @var \Psr\Log\LoggerInterface|\Prophecy\Prophecy\ProphecyInterface
   */
  protected $logger;

  /**
   * {@inheritdoc}
   */
  protected function setUp() {
    parent::setUp();

    $this->httpClient = $this->prophesize('\GuzzleHttp\ClientInterface');
    $this->cache = $this->prophesize('\Drupal\Core\Cache\CacheBackendInterface');
    $this->logger = $this->prophesize('\Psr\Log\LoggerInterface');
  }

  /**
   * Create a mocked API provider.
   *
   * @param string $url
   *   The URL that should be generated by the provider.
   * @param string $method
   *   (optional) The request method. If not provided, the stubbed
   *   Request::getMethod() will return NULL and prevent caching by the client.
   *
   * @return \PHPUnit_Framework_MockObject_MockObject
   *   The mocked API provider.
   */
  protected function mockProvider($url, $method = '') {
    $request = $this->getMock('Psr\Http\Message\RequestInterface');
    // Just borrowing this method for test ID purposes.
    $request->expects($this->any())
      ->method('getRequestTarget')
      ->willReturn($url);
    $request->expects($this->any())
      ->method('withHeader')
      ->willReturnSelf();
    if (!empty($method)) {
      $request->expects($this->any())
        ->method('getMethod')
        ->willReturn($method);
    }

    $provider = $this->getMock('Drupal\apiservices\ApiProviderInterface');
    $provider->expects($this->any())
      ->method('getRequest')
      ->willReturn($request);
    $provider->expects($this->any())
      ->method('getRequestUrl')
      ->willReturn($url);
    return $provider;
  }

  /**
   * Creates a mocked HTTP response.
   *
   * @param string $body
   *   (optional) The response body.
   * @param array $headers
   *   (optional) A list of response headers.
   * @param mixed $with_headers
   *   (optional) A response object to return if the response is cloned when
   *   adding or removing a header. If this value is FALSE, the current response
   *   object will be returned instead.
   *
   * @return \PHPUnit_Framework_MockObject_MockObject
   *   The mocked response.
   */
  protected function mockResponse($body = '', array $headers = [], $code = 200) {
    $response = $this->getMock('GuzzleHttp\Psr7\Response');
    $response->expects($this->any())
      ->method('getBody')
      ->willReturn($body);
    $response->expects($this->any())
      ->method('getStatusCode')
      ->willReturn($code);
    $response->expects($this->any())
      ->method('getHeaders')
      ->willReturn(array_filter($headers));
    $header_map = [];
    $header_line_map = [];
    $header_exists_map = [];
    foreach ($headers as $header => $value) {
      if ($value === FALSE) {
        $header_exists_map[] = [$header, FALSE];
      }
      else {
        $header_map[] = [$header, $value];
        $header_line_map[] = [$header, implode(', ', $value)];
        $header_exists_map[] = [$header, TRUE];
      }
    }
    if (!empty($header_exists_map)) {
      $response->expects($this->any())
        ->method('getHeader')
        ->will($this->returnValueMap($header_map));
      $response->expects($this->any())
        ->method('getHeaderLine')
        ->will($this->returnValueMap($header_line_map));
      $response->expects($this->any())
        ->method('hasHeader')
        ->will($this->returnValueMap($header_exists_map));
    }
    return $response;
  }

  /**
   * Tests that an exception thrown with no response is handled correctly.
   *
   * @expectedException \Drupal\apiservices\Exception\EndpointException
   * @expectedExceptionMessage An unknown error occurred
   */
  public function testRequestException() {
    $this->cache->get(Argument::type('string'), Argument::any())
      ->willReturn(FALSE);

    $request = $this->prophesize('Psr\Http\Message\RequestInterface');
    $this->httpClient->send(Argument::type('Psr\Http\Message\RequestInterface'), Argument::type('array'))
      ->willThrow(new RequestException('unable to establish connection', $request->reveal()));

    $client = new ApiClient($this->httpClient->reveal(), $this->cache->reveal(), $this->logger->reveal());
    $client->request($this->mockProvider('http://example.com/test'));
  }

  /**
   * Tests that a request is made if the cached response is stale.
   */
  public function testRequestStaleCache() {
    $now = time();

    $updated_headers = [
      'date' => date('r', $now),
      'expires' => date('r', $now + 120),
    ];
    $updated_response = $this->prophesize('Drupal\apiservices\ApiResponseInterface');
    $updated_response->getHeaders()->willReturn($updated_headers);
    $updated_response->getHeader('Date')->willReturn($updated_headers['date']);
    $updated_response->getHeader('Expires')->willReturn($updated_headers['expires']);

    $cached_headers = [
      'date' => date('r', $now - 60),
      'expires' => date('r', $now + 60),
    ];
    $cached_response = $this->prophesize('Drupal\apiservices\ApiResponseInterface');
    $cached_response->getHeaders()->willReturn($cached_headers);
    // The 'Date' header should be used for an 'If-Modified-Since' header.
    $cached_response->getHeader('Date')
      ->willReturn($cached_headers['date'])
      ->shouldBeCalled();
    // A cache lifetime header would also have been required, since the mocked
    // provider does not implement CacheableApiInterface.
    $cached_response->getHeader('Expires')->willReturn($cached_headers['expires']);
    $cached_response->withHeaders($updated_headers)->willReturn($updated_response->reveal());

    $cache = new \stdClass();
    $cache->valid = FALSE;
    $cache->data = $cached_response->reveal();
    $this->cache->get('stale', Argument::any())->willReturn($cache);
    $this->cache->set('stale', Argument::type('Drupal\apiservices\ApiResponseInterface'), Argument::type('int'))
      ->willReturn(NULL);

    $http_response = $this->mockResponse('', ['Date' => [date('r', $now)], 'Expires' => [date('r', $now + 120)]], 304);
    $http_response->expects($this->any())
      ->method('withoutHeader')
      ->willReturnSelf();
    $this->httpClient->send(Argument::type('Psr\Http\Message\RequestInterface'), Argument::type('array'))
      ->willReturn($http_response)
      ->shouldBeCalled();

    $client = new ApiClient($this->httpClient->reveal(), $this->cache->reveal(), $this->logger->reveal());
    $response = $client->request($this->mockProvider('stale', 'GET'));
    $this->assertEquals(date('r', $now + 120), $response->getHeader('Expires'));
  }

  /**
   * Tests that a cached response is returned instead of being sent.
   */
  public function testRequestValidCache() {
    $cache = new \stdClass();
    $cache->valid = TRUE;
    $cache->data = 'valid';
    $this->cache->get('cached', Argument::any())->willReturn($cache);

    $this->httpClient->send(Argument::type('Psr\Http\Message\RequestInterface'), Argument::type('array'))
      ->shouldNotBeCalled();

    $client = new ApiClient($this->httpClient->reveal(), $this->cache->reveal(), $this->logger->reveal());
    $response = $client->request($this->mockProvider('cached'));
    $this->assertEquals('valid', $response);
  }

  /**
   * Tests that a single, uncached request is sent.
   */
  public function testRequestSend() {
    $this->cache->get(Argument::type('string'), Argument::any())
      ->willReturn(FALSE);
    // Assert that the response is not cached since it does not contain
    // 'Cache-Control' or 'Expires' headers.
    $this->cache->set(Argument::cetera())->shouldNotBeCalled();

    $this->httpClient->send(Argument::type('Psr\Http\Message\RequestInterface'), Argument::type('array'))
      ->willReturn($this->mockResponse('test', ['Date' => [date('r')]]));

    $client = new ApiClient($this->httpClient->reveal(), $this->cache->reveal(), $this->logger->reveal());
    $response = $client->request($this->mockProvider('notcached', 'GET'));
    $this->assertEquals('test', $response->getBody());
  }

  /**
   * Tests that cached responses are returned along with uncached ones.
   */
  public function testRequestMultiplePartialCached() {
    $cache_a = new \stdClass();
    $cache_a->valid = TRUE;
    $cache_a->data = 'response a';
    $this->cache->get('a', Argument::any())->willReturn($cache_a);
    $this->cache->get('b', Argument::any())->willReturn(FALSE);

    $providers = [
      'a' => $this->mockProvider('a'),
      'b' => $this->mockProvider('b'),
    ];

    $this->httpClient->sendAsync(Argument::which('getRequestTarget', 'b'), Argument::type('array'))
      ->willReturn($this->mockResponse('response b', ['Date' => [date('r')]]));

    $client = new ApiClient($this->httpClient->reveal(), $this->cache->reveal(), $this->logger->reveal());
    $responses = $client->requestMultiple($providers);
    $this->assertEquals('response a', $responses['a']);
    $this->assertEquals('response b', $responses['b']->getBody());
  }

  /**
   * Tests that multiple requests are sent asynchronously.
   */
  public function testRequestMultipleSend() {
    $this->cache->get(Argument::type('string'), Argument::any())
      ->willReturn(FALSE);

    $providers = [
      'a' => $this->mockProvider('a'),
      'b' => $this->mockProvider('b'),
    ];

    $this->httpClient->sendAsync(Argument::which('getRequestTarget', 'a'), Argument::type('array'))
      ->willReturn($this->mockResponse('response a', ['Date' => [date('r')]]));
    $this->httpClient->sendAsync(Argument::which('getRequestTarget', 'b'), Argument::type('array'))
      ->willReturn($this->mockResponse('response b', ['Date' => [date('r')]]));

    $client = new ApiClient($this->httpClient->reveal(), $this->cache->reveal(), $this->logger->reveal());
    $responses = $client->requestMultiple($providers);
    $this->assertEquals('response a', $responses['a']->getBody());
    $this->assertEquals('response b', $responses['b']->getBody());
  }

  /**
   * Tests responses that indicate an error condition, such as a '404 Not Found'.
   *
   * @dataProvider getResponseException
   */
  public function testResponseException($status_code, $expected) {
    $this->setExpectedException($expected);

    $this->cache->get(Argument::type('string'), Argument::any())
      ->willReturn(FALSE);

    $request = $this->prophesize('Psr\Http\Message\RequestInterface');
    $response = $this->mockResponse('', [], $status_code);
    $this->httpClient->send(Argument::type('Psr\Http\Message\RequestInterface'), Argument::type('array'))
      ->willThrow(new RequestException('something happened', $request->reveal(), $response));

    $client = new ApiClient($this->httpClient->reveal(), $this->cache->reveal(), $this->logger->reveal());
    $client->request($this->mockProvider('http://example.com/test'));
  }

  /**
   * Gets response status codes that should result in exceptions.
   */
  public function getResponseException() {
    return [
      [400, '\Drupal\apiservices\Exception\EndpointRequestException'],
      [403, '\Drupal\apiservices\Exception\EndpointDeniedException'],
      [404, '\Drupal\apiservices\Exception\EndpointNotFoundException'],
      [500, '\Drupal\apiservices\Exception\EndpointServerException'],
    ];
  }

  /**
   * Tests that a 'Date' header is added by the client if it is missing.
   */
  public function testResponseMissingDate() {
    $this->cache->get(Argument::type('string'), Argument::any())
      ->willReturn(FALSE);
    $this->cache->set(Argument::cetera())->shouldNotBeCalled();

    $http_response = $this->mockResponse();
    $http_response->expects($this->once())
      ->method('withHeader')
      ->with('Date')
      ->willReturn($this->mockResponse('', ['Date' => [date('r')]]));
    $this->httpClient->send(Argument::type('Psr\Http\Message\RequestInterface'), Argument::type('array'))
      ->willReturn($http_response);

    $client = new ApiClient($this->httpClient->reveal(), $this->cache->reveal(), $this->logger->reveal());
    $api_response = $client->request($this->mockProvider('test'));
  }

}
