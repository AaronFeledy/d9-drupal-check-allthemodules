<?php

define('CALENDAR_SYSTEMS_USE_INTL', FALSE && class_exists('IntlDateFormatter'));

use Drupal\block_content\BlockContentTranslationHandler;
use Drupal\comment\CommentTranslationHandler;
use Drupal\content_translation\ContentTranslationHandler;
use Drupal\calendar_systems\CalendarSystems\CalendarSystemsIntlCalendar;
use Drupal\calendar_systems\CalendarSystems\CalendarSystemsPersianIntlCalendar;
use Drupal\calendar_systems\CalendarSystems\CalendarSystemsPoorMansGregorianCalendar;
use Drupal\calendar_systems\CalendarSystems\CalendarSystemsPoorMansJaliliCalendar;
use Drupal\calendar_systems\Plugin\Field\FieldWidget\CalendarSystemsDateTimeDatelistWidget;
use Drupal\calendar_systems\Plugin\Field\FieldWidget\CalendarSystemsDateTimeDefaultWidget;
use Drupal\calendar_systems\Plugin\Field\FieldWidget\CalendarSystemsTimestampDatetimeNoDefaultWidget;
use Drupal\calendar_systems\Plugin\Field\FieldWidget\CalendarSystemsTimestampDatetimeWidget;
use Drupal\calendar_systems\Plugin\views\argument\CalendarSystemsDateDate;
use Drupal\calendar_systems\Plugin\views\argument\CalendarSystemsDateFullDate;
use Drupal\calendar_systems\Plugin\views\argument\CalendarSystemsViewsDate as CalendarSystemsViewsDate_Arg;
use Drupal\calendar_systems\Plugin\views\argument\CalendarSystemsViewsFullDate;
use Drupal\calendar_systems\Plugin\views\filter\CalendarSystemsViewsDate as CalendarSystemsViewsDate_Filter;
use Drupal\calendar_systems\Plugin\views\filter\CalendarSystemsViewsDateTime;
use Drupal\calendar_systems\TranslationHack\CalendarSystemsContentTranslationHandler;
use Drupal\node\NodeTranslationHandler;
use Drupal\taxonomy\TermTranslationHandler;
use Drupal\user\ProfileTranslationHandler;

function calendar_systems_factory($tz = NULL, $lang_code = '', $calendar_name = '') {
  // COPY FROM common.inc::format_date() (drupal 7).
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['timezones'] = [];
  }
  $timezones = &$drupal_static_fast['timezones'];

  if (!$tz) {
    $tz = drupal_get_user_timezone();
  }
  if (is_string($tz)) {
    if (!isset($timezones[$tz])) {
      $timezones[$tz] = timezone_open($tz);
    }
    $tz = $timezones[$tz];
  }

  if (!$calendar_name) {
    $for_lang = \Drupal::languageManager()->getCurrentLanguage()->getId();
    if (count(\Drupal::languageManager()
        ->getLanguages()) === 1 || $for_lang === 'fa') {
      $calendar_name = 'persian';
    }
    elseif ($for_lang === 'en') {
      $calendar_name = 'gregorian';
    }
  }
  if (!$calendar_name) {
    return NULL;
  }

  if (!$lang_code) {
    if (count(\Drupal::languageManager()->getLanguages()) === 1) {
      $lang_code = 'fa';
    }
    else {
      $lang_code = \Drupal::languageManager()->getCurrentLanguage()->getId();
    }
  }

  if (!CALENDAR_SYSTEMS_USE_INTL) {
    switch ($calendar_name) {
      case 'persian':
        return new CalendarSystemsPoorMansJaliliCalendar(is_string($tz) ? timezone_open($tz) : $tz, $lang_code);
      default:
        return new CalendarSystemsPoorMansGregorianCalendar(is_string($tz) ? timezone_open($tz) : $tz, $lang_code);
    }
  }
  switch ($calendar_name) {
    case 'persian':
      return new CalendarSystemsPersianIntlCalendar($tz, $calendar_name, $lang_code);
    default:
      return new CalendarSystemsIntlCalendar($tz, $calendar_name, $lang_code);
  }
}

/**
 * Implements hook_entity_type_alter().
 */
function calendar_systems_entity_type_alter(array &$entity_types) {
  $supported = [
    BlockContentTranslationHandler::class,
    CommentTranslationHandler::class,
    ContentTranslationHandler::class,
    NodeTranslationHandler::class,
    ProfileTranslationHandler::class,
    TermTranslationHandler::class,
  ];

  if (!\Drupal::moduleHandler()->moduleExists('content_translation')) {
    return;
  }

  /** @var \Drupal\Core\Entity\EntityTypeInterface $type */
  foreach ($entity_types as $type) {
    if (!$type->isTranslatable()) {
      continue;
    }
    if (!$type->hasHandlerClass('translation')) {
      $type->setHandlerClass('translation', CalendarSystemsContentTranslationHandler::class);
      continue;
    }
    $handler = $type->getHandlerClass('translation');
    if (!in_array($handler, $supported, TRUE)) {
      continue;
    }
    $handler = explode('\\', $handler);
    $handler = array_pop($handler);
    $type->setHandlerClass('translation', '\Drupal\calendar_systems\TranslationHack\CalendarSystems' . $handler);
  }
}

/**
 * Implements hook_element_info_alter().
 *
 * Swap drupal elements with calendar_systems elements.
 */
function calendar_systems_element_info_alter(array &$info) {
  $rep = function ($find_for) {
    switch ($find_for) {
      case \Drupal\Core\Datetime\Element\Datelist::class:
        $rep = \Drupal\calendar_systems\Element\CalendarSystemsDateList::class;
        break;
      case \Drupal\Core\Datetime\Element\Datetime::class:
        $rep = \Drupal\calendar_systems\Element\CalendarSystemsDateTime::class;
        break;
      case \Drupal\Core\Render\Element\Date::class:
        $rep = \Drupal\calendar_systems\Element\CalendarSystemsDate::class;
        break;
      default:
        $rep = NULL;
    }
    return $rep;
  };
  foreach (['date', 'datelist', 'datetime'] as $el_) {
    if (!isset($info[$el_])) {
      continue;
    }
    $el = &$info[$el_];
    if ($el_ === 'date' || $el_ === 'datetime') {
      $el['#attached']['library'][] = 'calendar_systems/picker';
    }
    foreach ([
               '#process',
               '#pre_render',
               '#element_validate',
               '#value_callback',
             ] as $attr_) {
      if (!isset($el[$attr_])) {
        continue;
      }
      foreach ($el[$attr_] as $ai => &$a) {
        if (is_array($a)) {
          $a[0] = $rep($a[0]) ?: $a[0];
        }
        else {
          $el[$attr_][$ai] = $rep($a) ?: $a;
        }
      }
    }
  }
}

/**
 * Implements hook_field_widget_info_alter().
 */
function calendar_systems_field_widget_info_alter(&$info) {
  $info['datetime_default']['class'] = CalendarSystemsDateTimeDefaultWidget::class;
  $info['datetime_datelist']['class'] = CalendarSystemsDateTimeDatelistWidget::class;
  $info['datetime_timestamp']['class'] = CalendarSystemsTimestampDatetimeWidget::class;
  if (isset($info['datetime_timestamp_no_default'])) {
    $info['datetime_timestamp_no_default']['class'] = CalendarSystemsTimestampDatetimeNoDefaultWidget::class;
  }
  foreach ([
             'default',
             'datelist',
             'timestamp',
             'timestamp_no_default',
           ] as $item) {
    $info["datetime_$item"]['provider'] = 'calendar_systems';
  }
}

/**
 * Implements hook_views_plugins_filter_alter().
 */
function calendar_systems_views_plugins_filter_alter(array &$plugins) {
  $plugins['date']['class'] = CalendarSystemsViewsDate_Filter::class;
  $plugins['datetime']['class'] = CalendarSystemsViewsDatetime::class;
}

/**
 * Implements hook_views_plugins_argument_alter().
 */
function calendar_systems_views_plugins_argument_alter(array &$plugins) {
  if (isset($plugins['datetime'])) {
    $plugins['datetime']['class'] = CalendarSystemsDateDate::class;
  }
  if (isset($plugins['datetime_full_date'])) {
    $plugins['datetime_full_date']['class'] = CalendarSystemsDateFullDate::class;
  }
  if (isset($plugins['date'])) {
    $plugins['date']['class'] = CalendarSystemsViewsDate_Arg::class;
  }
  if (isset($plugins['date_fulldate'])) {
    $plugins['date_fulldate']['class'] = CalendarSystemsViewsFullDate::class;
  }
}

