<?php


namespace Drupal\enterprise_search\Plugin\search_api\backend;

use Drupal\Core\Config\Config;
use Drupal\Core\Extension\ModuleHandlerInterface;
use Drupal\Core\Language\LanguageManagerInterface;
use Drupal\search_api\Query\QueryInterface;
use Drupal\search_api\SearchApiException;
use Drupal\search_api\Utility\DataTypeHelperInterface;
use Drupal\search_api\Utility\FieldsHelperInterface;
use Drupal\search_api_autocomplete\SearchInterface;
use Drupal\search_api_solr\Plugin\search_api\backend\SearchApiSolrBackend;
use Drupal\Core\Form\FormStateInterface;
use Drupal\search_api_solr\SolrConnector\SolrConnectorPluginManager;
use GuzzleHttp\Psr7\Request;
use Solarium\Core\Event\Events;
use Solarium\Core\Event\PreExecuteRequest;
use Solarium\Client;
use Drupal\a12_connect\Inc\A12Config;
use Drupal\search_api_autocomplete\Suggestion;



/**
 * Class EnterpriseSearchApiPlugin
 *
 * @package Drupal\enterprise_search\Plugin\search_api\backend\
 *
 * @SearchApiBackend(
 *   id = "enterprise_search_solr_backend",
 *   label = @Translation("Enterprise Search Solr"),
 *   description = @Translation("Index items using an AxisTwelve Apache Solr search server.")
 * )
 */
class EnterpriseSearchApiPlugin extends SearchApiSolrBackend {
    public function __construct(array $configuration, $plugin_id, array $plugin_definition, ModuleHandlerInterface $module_handler, Config $search_api_solr_settings, LanguageManagerInterface $language_manager, SolrConnectorPluginManager $solr_connector_plugin_manager, FieldsHelperInterface $fields_helper, DataTypeHelperInterface $dataTypeHelper) {
      parent::__construct($configuration, $plugin_id, $plugin_definition, $module_handler, $search_api_solr_settings, $language_manager, $solr_connector_plugin_manager, $fields_helper, $dataTypeHelper);
    }

    public function defaultConfiguration() {
      return array(
        'excerpt' => FALSE,
        'retrieve_data' => FALSE,
        'highlight_data' => FALSE,
        'skip_schema_check' => FALSE,
        'site_hash' => FALSE,
        'suggest_suffix' => TRUE,
        'suggest_corrections' => TRUE,
        'suggest_words' => FALSE,
        'connector' => 'basic_auth',
        'connector_config' => array(
          'scheme'                    => 'http', //@todo Change this https://
          'host'                      => '192.168.81.2',
          'port'                      => '80',
          'path'                      => '/solr',
          'commit_within'             => 1,
          'core'                      => '',
          'username'                  => '',
          'password'                  => '',
          'excerpt'                   => FALSE,
          'retrieve_data'             => FALSE,
          'highlight_data'            => FALSE,
          'skip_schema_check'         => FALSE,
          'solr_version'              => '5.x',
          'http_method'               => 'AUTO',
          'site_hash'                 => TRUE,
          'autocorrect_spell'         => TRUE,
          'autocorrect_suggest_words' => TRUE,
        )
      );
    }


    public function buildConfigurationForm(array $form, FormStateInterface $form_state) {
        $form = parent::buildConfigurationForm($form, $form_state);

        $form['connector_config']['#disabled'] = TRUE;
        hide($form['connector_config']['auth']);
        hide($form['connector_config']['core']);

        if ($this->server->isNew()) {
          A12Config::setSolrPath($form['connector_config']['path']['#default_value']);
        }

        $this->addIndexesToForm($form, $form_state);
        return $form;

    }

    public function buildConnectorConfigForm(array &$form, FormStateInterface $form_state) {
      parent::buildConnectorConfigForm($form, $form_state); // TODO: Change the autogenerated stub
    }


    public function addIndexesToForm(array &$form, $form_state)
      {
          $response = $this->getIndices();

          $radios = array();
          $radios['disabled'] = 'Disabled';
          $form['find_index']['active'] = array (
              '#type'             => 'radios',
              '#required'         => TRUE,
              '#title'            => $this->t("Choose Index"),
              '#options'          => $response,
              '#default_value'    => $this->server->getBackendConfig()['find_index']['active']
          );
      }


    public function getIndices(){
        $url = 'http://192.168.81.2/index/cores/get'; //@TODO Change to config variable

        $username = A12Config::getId();
        $password = A12Config::getSecret();

        $client = new \GuzzleHttp\Client();
        $body = array(
            'username' => $username,
            'password' => $password
        );

        $request = new Request("POST", $url, array(), json_encode($body));
        $response = $client->send($request);
        $response = unserialize($response->getBody()->getContents());

        A12Config::setIndicies($response);

        return $response;
    }

    /**
     * Creates a connection to the Solr server as configured in $this->configuration.
     */
    protected function connect() {
        if (!$this->solr) {
            $this->solr = new Client();

            $dispatcher = $this->solr->getEventDispatcher();
            $dispatcher->addListener(Events::PRE_EXECUTE_REQUEST, array ($this, 'preExecuteRequest'), -1);

            $this->solr->createEnpoint($this->configuration + ['key' => 'core'], TRUE);
            $this->getSolrHelper()->setSolr($this->solr);
        }
    }

    public function setConfiguration(array $configuration) {
      parent::setConfiguration($configuration);

      $this->configuration['connector_config']['username'] = A12Config::getId();
      $this->configuration['connector_config']['password'] = A12Config::getSecret();

    }

  public function submitConfigurationForm(array &$form, FormStateInterface $form_state) {
//        die(var_dump($this->configuration));
        $selectedIndex = $form_state->getValue(
          array('find_index', 'active')
        );

        $path = A12Config::getSolrPath();

        $form_state->setValue(
          array('connector_config', 'path'),
          "$path/" . $selectedIndex
        );
        parent::submitConfigurationForm($form, $form_state);
    }


    public function getAutocompleteSuggestions(QueryInterface $query, SearchInterface $search, $incomplete_key, $user_input) {
      {
        $suggestions = [];
        $search_fields = [];
        foreach($search->getSuggesterInstance()->getConfiguration()['fields'] as $key => $value) {
          if ($value != '0') {
            $search_fields[] = 'tes_' . $value;
          }
        }

        if ($this->configuration['suggest_suffix'] || $this->configuration['suggest_corrections'] || $this->configuration['suggest_words']) {
          $connector = $this->getSolrConnector();
          $solr_version = $connector->getSolrVersion();
          if (version_compare($solr_version, '6.5', '=')) {
            \Drupal::logger('search_api_solr')->error('Solr 6.5.x contains a bug that breaks the autocomplete feature. Downgrade to 6.4.x or upgrade to 6.6.x.');
            return [];
          }
          $solarium_query = $connector->getTermsQuery();
          $schema_version = $connector->getSchemaVersion();

          $solarium_query->setHandler('select');

          try {
            $fl = [];
            if (version_compare($schema_version, '5.4', '>=')) {
              $solr_field_names = $this->getSolrFieldNames($query->getIndex());
              $fulltext_fields = $search->getOption('fields') ? $search->getOption('fields') : $this->getQueryFulltextFields($query);
              foreach ($fulltext_fields as $fulltext_field) {
                $fl[] = 'terms_' . $solr_field_names[$fulltext_field];
              }
            }
            else {
              $fl[] = 'spell';
            }
            $solarium_query->setFields($fl);
            $solarium_query->setPrefix($incomplete_key);
            $solarium_query->setLimit(10);

            if ($this->configuration['suggest_corrections']) {
              $q = '';

              foreach ($search_fields as $k => $field) {
                $q .= $field . ":" . $user_input . "* OR " . $field . ":*" . $user_input . "*";
                if ($k != sizeof($search_fields) - 1)
                $q .= " OR ";
              }
              $solarium_query->addParam('q', $q);
              $solarium_query->addParam('spellcheck', 'true');
              $solarium_query->addParam('spellcheck.count', 1);
            }

            /** @var \Solarium\QueryType\Terms\Result $terms_result */
            $terms_result = $connector->execute($solarium_query);

            $terms = $terms_result->getData()['response']['docs'];
            foreach($terms as $term) {
              foreach ($search_fields as $field) {
                $suggestions[] = Suggestion::fromSuggestedKeys($term[$field], $user_input);
//                $suggestions[] = Suggestion::fromSuggestionSuffix(mb_substr($term[$field], mb_strlen($incomplete_key)),0, $user_input);
              }
            }
          }
          catch (SearchApiException $e) {
            watchdog_exception('search_api_solr', $e);
            return [];
          }

        }
        return $suggestions;
      }
    }

  public function preExecuteRequest(PreExecuteRequest $event) {}
}