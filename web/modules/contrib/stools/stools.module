<?php

/**
 * @file
 * Defines functionality for stools.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\Entity;

/**
 * Make sure the value is an array.
 */
function stools_assert_array(&$value) {
  if (!is_array($value)) {
    $value = [$value];
  }
}

/**
 * Concatenate multiple field values into a string.
 *
 * @param object $entity
 *   The entity with a field.
 * @param array $fields
 *   An array of field names.
 * @param string $concat
 *   The concatentation string. Defaults to ', '.
 * @param string $language
 *   The language. Defaults to LANGUAGE_NONE.
 *
 * @return string
 *   A string of the fields values
 */
function stools_concat_field_values($entity, array $fields, $concat = ', ', $language = LANGUAGE_NONE) {
  $value = NULL;

  foreach ($fields as $field) {
    if (stools_field_has_value($entity, $field, $language)) {
      if ($value === NULL) {
        $value = '';
      }
      else {
        $value .= $concat;
      }
      $value .= stools_field_value($entity, $field, $language);
    }
  }

  return $value;
}

/**
 * Content variable has a value.
 */
function stools_content_has_value($content, $field) {
  if (isset($content[$field])) {
    $content_keys = array_keys($content[$field]);
    $content_keys = array_filter($content_keys, 'stools_filter_render_array_keys');
    foreach ($content_keys as $key) {
      if (isset($content[$field][$key]['#markup']) && $content[$field][$key]['#markup']) {
        return TRUE;
      }
    }
  }
  return FALSE;
}

/**
 * Check if the field contains a specific value.
 *
 * This checks the value/target_id of the field to see if it contains the
 * specified value.
 *
 * @param object $entity
 *   The entity object.
 * @param string $field
 *   A string for the field name.
 * @param mixed $value
 *   A value to see if the field contains.
 * @param string $language
 *   The language to check. Defaults to LANGUAGE_NONE.
 *
 * @return bool
 *   TRUE if the field contains the specified value, FALSE if not.
 */
function stools_field_contains_value($entity, $field, $value, $language = NULL) {
  // Does the entity have the field?
  if (!isset($entity->$field)) {
    return FALSE;
  }

  $entity_field = $entity->$field;

  $values = stools_field_value($entity, $field);
  if (!is_array($values)) {
    $values = [$values];
  }

  return in_array($value, $values);
}

/**
 * Check if a field has a value.
 *
 * @param \Drupal\Core\Entity\Entity $entity
 *   The entity object.
 * @param string $field
 *   A string for the field name.
 *
 * @return bool
 *   TRUE if the field has a value and FALSE if not.
 */
function stools_field_has_value(Entity $entity, $field, $language = NULL) {
  if (!is_object($entity)) {
    var_dump($entity);
    debug_print_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS);
  }
  if (!$entity) {
    return FALSE;
  }

  if (!$entity->hasField($field)) {
    return FALSE;
  }

  $field_value = $entity->$field->getValue();
  return !empty($field_value);
}

/**
 * Get the value of a field.
 *
 * Options:
 * - simplify: true/false. This function will reduce the values of common fields
 *   to their key values. If you want the raw value, you should set this to
 *   FALSE. Supported types built in: value, target_id, product_id. See the
 *   'key' option to specify your own!
 * - key: string. If simplify is being used, you can specify a key you want
 *   from array values.
 *
 * @param \Drupal\Core\Entity\Entity $entity
 *   The entity object.
 * @param string $field
 *   The field name to get the value of.
 * @param string $language
 *   The language. Defaults to LANGUAGE_NONE.
 * @param array $options
 *   An array of optional options.
 */
function stools_field_value(Entity $entity, $field, $language = NULL, array $options = []) {
  $options = array_merge([
    'simplify' => TRUE,
    'key' => NULL,
  ], $options);

  if (!stools_field_has_value($entity, $field, $language)) {
    return NULL;
  }

  $value = $entity->$field->getValue();
  $count = count($value);
  $key = NULL;

  // Simplify values are used to reduce the value of a field to the key
  // information.
  if ($options['simplify']) {
    $simplify_values = ['value', 'target_id', 'product_id'];
    if ($options['key']) {
      $simplify_values[] = $options['key'];
    }
    foreach ($simplify_values as $simple) {
      if (isset($value[0][$simple])) {
        $key = $simple;
      }
    }
  }

  $values = [];
  foreach ($value as $val) {
    if ($key) {
      $values[] = $val[$key];
      continue;
    }

    $values[] = $val;
  }

  if ($count === 1) {
    return $values[0];
  }

  return $values;
}

/**
 * Return only numeric keys from a render array.
 */
function stools_filter_render_array_keys($key) {
  return is_numeric($key);
}

/**
 * Get the class for this entity.
 */
function stools_get_entity_class($entity_type) {
  $type = Drupal::entityTypeManager()->getDefinition($entity_type);
  if (!$type) {
    throw new Exception('Could not load entity type: ' . $entity_type);
  }
  return $type->getClass();
}

/**
 * Returns the menu_links depth of the current page.
 *
 * @return int
 *   The menu link depth or FALSE if not found.
 */
function stools_how_deep() {
  $depth_query = db_query(
    'SELECT depth FROM menu_links where link_path = :path',
    [':path' => implode('/', arg())]
  );
  $depth = $depth_query->fetchCol();
  if ($depth) {
    return $depth[0];
  }
  return FALSE;
}

/**
 * Check if the entity is the entity type/bundle.
 */
function stools_is_entity_bundle(EntityInterface $entity, $entity_type, $bundle = NULL) {
  if (!$entity->getEntityTypeId() == $entity_type) {
    return FALSE;
  }

  if ($bundle && $entity->bundle() != $bundle) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Get entities referenced by this entity.
 *
 * If you have an entity A which references some other entities using an
 * entity reference field, this function will return the targeted IDs. This does
 * a database query, whereas stools_field_value can return the target IDs
 * available on an existing/loaded object.
 *
 * @param int $entity_id
 *   The entity ID that is doing the referencing.
 * @param string $reference_field
 *   The name of the field that provides the reference.
 * @param string $entity_type
 *   Defaults to 'node'.
 *
 * @return array
 *   An array of target id's.
 */
function stools_get_entities_referenced_by_this_entity($entity_id, $reference_field, $entity_type = 'node') {
  $data_table = 'field_data_' . $reference_field;
  $target_field = $reference_field . '_target_id';

  $info = entity_get_info($entity_type);
  $base_table = $info['base table'];
  $id_field = $info['entity keys']['id'];

  $query = db_select($data_table, 'd');

  // Join with the entity table.
  $join_condition = 'd.entity_id=e.' . $id_field;
  if (isset($info['entity keys']['revision']) && $info['entity keys']['revision']) {
    $join_condition .= ' AND d.revision_id=e.' . $info['entity keys']['revision'];
  }
  $query->join($base_table, 'e', $join_condition);
  $query->fields('d', [$target_field]);
  $query->condition('entity_id', $entity_id);

  $targets = [];
  $results = $query->execute();
  while ($result = $results->fetchAssoc()) {
    if (!in_array($result[$target_field], $targets)) {
      array_push($targets, $result[$target_field]);
    }
  }

  return $targets;
}

/**
 * Find entities that reference this entity.
 *
 * If you have some nodes that reference this entity, you can use this to find
 * them. For example, if you have an Article content type and an Author content
 * type. You can find the articles that reference an article with:
 *
 *     $author_node = node_load(123);
 *     $articles = stools_get_entities_that_reference_this_entity(
 *       123,
 *       'field_author',
 *       'node',
 *       'article'
 *     );
 *
 * The filters array allows you to specify more conditions:
 *
 *     // find unpublished articles
 *     $articles = stools_get_entities_that_reference_this_entity(
 *       123,
 *       'field_author',
 *       'node',
 *       'article',
 *       array(
 *         array('condition', 'status', '0')
 *       )
 *     );
 *
 * @param int $entity_id
 *   The entity id to look for (the target id).
 * @param string $reference_field
 *   The field name that is used by the referencing nodes to reference this
 *   entity.
 * @param string $target_entity_type
 *   The entity type to query against. Defaults to 'node'.
 * @param string $target_bundle
 *   The bundle to query against. Defaults to NULL (doesn't target anything).
 * @param array $filters
 *   An array of filters.
 *
 * @return array
 *   Returns an array of results. If $target_entity_type is specified, this will
 *   return an array of the entity id's for that type. Otherwise, it will return
 *   the EntityFieldQuery results verbatium.
 */
function stools_get_entities_that_reference_this_entity($entity_id, $reference_field, $target_entity_type = 'node', $target_bundle = NULL, array $filters = []) {
  $query = \Drupal::entityQuery($target_entity_type);
  if ($target_bundle) {
    $query->condition('type', $target_bundle);
  }
  $query->condition($reference_field, $entity_id, '=');

  foreach ($filters as $filter) {
    $function = $filter[0];
    $args = $filter;
    array_shift($args);
    if (method_exists($query, $function)) {
      call_user_func_array([$query, $function], $args);
    }
  }

  $results = $query->execute();

  if ($target_entity_type && isset($results[$target_entity_type])) {
    return array_keys($results[$target_entity_type]);
  }

  return $results;
}

/**
 * Returns img markup for an image style from a given field on given node.
 *
 * Useful for grabbing images from referenced nodes.
 *
 * @param object $node
 *   The entity object.
 * @param string $field
 *   (optional) The machine name of the desired image field.
 * @param string $image_style
 *   (optional) The machine name of the desired image style.
 * @param string $image_field
 *   The field name for the image field on the image node. Defaults to
 *   'field_image'.
 *
 * @return array
 *   The HTML markup for the img tag.
 */
function stools_get_image_from_node($node, $field, $image_style = 'medium', $image_field = 'field_image') {
  // Get the image node.
  $wrapper = entity_metadata_wrapper('node', $node);
  if (!isset($wrapper->{$field})) {
    return FALSE;
  }
  $image_node = $wrapper->{$field}->value();

  // Return false if no image node is referenced.
  if (!$image_node) {
    return FALSE;
  }

  // Only used the first value in a multivalue field.
  if (is_array($image_node)) {
    $image_node = $image_node[0];
  }

  $image_wrapper = entity_metadata_wrapper('node', $image_node);
  $image_file = $image_wrapper->{$image_field}->value();

  // Return false if no image file is set.
  if (!$image_file) {
    return FALSE;
  }

  // Create image markup.
  return theme_image_style([
    'style_name' => $image_style,
    'path' => $image_file['uri'],
    'height' => $image_file['height'],
    'width' => $image_file['width'],
    'alt' => $image_file['alt'],
    'title' => $image_file['title'],
  ]);
}

/**
 * Load and render a block.
 *
 * @param string $block_module
 *   The module machine name providing the block.
 * @param string $block_name
 *   The block machine name.
 * @param string $block_id
 *   The block id.
 *
 * @return string
 *   The rendered block code
 */
function stools_render_block($block_module, $block_name, $block_id = NULL) {
  if (empty($block_id)) {
    $block_id = $block_module . '_' . $block_name;
  }
  $block = [
    block_load($block_module, $block_name),
  ];
  if (!isset($block[0]->title) || $block[0]->title == '') {
    $block[0]->title = NULL;
  }
  if (!isset($block[0]->region) || $block[0]->region == '') {
    $block[0]->region = NULL;
  }

  $blocks_array = _block_get_renderable_array(_block_render_blocks($block));
  return drupal_render($blocks_array[$block_id]);
}

/**
 * Creates a simple text rows array from a field collections.
 *
 * To be used in a field_preprocess function.
 *
 * Credit: Mike Minecki
 * http://fourword.fourkitchens.com/article/better-way-theme-field-collections
 *
 * @param array $vars
 *   An array of variables to pass to the theme template.
 * @param array $field_array
 *   Array of fields to be turned into rows in the field collection.
 */
function stools_rows_from_field_collection(array &$vars, array $field_array) {
  if (module_exists('field_collection')) {
    $vars['rows'] = [];
    foreach (array_values($vars['element']['#items']) as $item) {
      $entity_id = $item['value'];
      $entity = field_collection_item_load($entity_id);
      $wrapper = entity_metadata_wrapper('field_collection_item', $entity);
      $row = [];
      foreach ($field_array as $field) {
        $row[$field] = $wrapper->$field->value();
      }
      $vars['rows'][] = $row;
    }
  }
}

/**
 * Check if a string starts with another string.
 */
function stools_string_startswith($string, $needle) {
  if ($string === $needle) {
    return TRUE;
  }
  if (function_exists('mb_substr')) {
    return mb_substr($string, 0, mb_strlen($needle)) === $needle;
  }
  return substr($string, 0, strlen($needle)) === $needle;
}

/**
 * Check if a string ends with another string.
 */
function stools_string_endswith($string, $needle) {
  if ($string === $needle) {
    return TRUE;
  }
  if (function_exists('mb_substr')) {
    return mb_substr($string, -1 * mb_strlen($needle)) === $needle;
  }
  return substr($string, -1 * strlen($needle)) === $needle;
}

/**
 * Check if the term has parent terms.
 *
 * @param object $term
 *   The taxonomy term.
 */
function stools_term_has_parent($term) {
  if (taxonomy_get_parents($term->tid)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Check if the term is a parent term.
 *
 * @param object $term
 *   The taxonomy term.
 */
function stools_term_is_parent($term) {
  $children = taxonomy_get_tree($term->vid, $term->tid);
  if ($children) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Return the tid for the first term that matches.
 *
 * @param string $term_name
 *   The term name to search for.
 * @param string $vocab
 *   Limit the search to this vocab machine name.
 *
 * @return mixed
 *   Returns the tid or FALSE if not found.
 */
function stools_term_tid($term_name, $vocab = NULL) {
  $term = taxonomy_get_term_by_name($term_name, $vocab);
  if ($term) {
    return array_shift(array_keys($term));
  }
  return FALSE;
}

/**
 * Determine if we should use the cached object.
 *
 * @param object $cache
 *   The cache object returned from cache_get().
 * @param int $time
 *   Timestamp to check against. Will use REQUEST_TIME by default.
 *
 * @return bool
 *   Returns TRUE if you can use the cache or FALSE if not.
 */
function stools_use_cache($cache, $time = NULL) {
  if (!$time && defined('REQUEST_TIME')) {
    $time = REQUEST_TIME;
  }
  elseif (!$time) {
    $time = time();
  }

  // CACHE_TEMPORARY items are set to -1 and CACHE_PERMANENT items are set to 0.
  if ($cache->expire <= 0) {
    return TRUE;
  }
  if ($cache->expire > 0 && $time < $cache->expire) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Check if a user has a role.
 *
 * @param mixed $role
 *   The role or an array of roles to check.
 * @param object $account
 *   The user object to check.
 *
 * @return bool
 *   Whether or not the user has ALL of the roles
 */
function stools_user_has_role($role, $account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }

  if (!is_array($role)) {
    $role = [$role];
  }

  $has_roles = TRUE;
  foreach ($role as $role_name) {
    if (!in_array($role_name, $account->roles)) {
      $has_roles = FALSE;
      break;
    }
  }

  return $has_roles;
}

/**
 * Wrapper around stools_user_has_role().
 */
function stools_user_has_roles($role, $account = NULL) {
  return stools_user_has_role($role, $account);
}

/**
 * Creates basic pages.
 *
 * @param array $pages
 *   Array of pages with title and path keys.
 */
function stools_create_basic_pages(array $pages) {
  $values = [
    'type' => 'page',
    'uid' => 1,
    'status' => 1,
    'comment' => 0,
    'promote' => 0,
  ];

  foreach ($pages as $page) {
    $nid_path = drupal_lookup_path('source', $page['path']);
    if (!$nid_path) {
      $entity = entity_create('node', $values);
      $wrapper = entity_metadata_wrapper('node', $entity);
      $wrapper->title->set($page['title']);
      $wrapper->save();

      $nid_path = 'node/' . $wrapper->getIdentifier();

      $path = [
        'source' => $nid_path,
        'alias' => $page['path'],
      ];

      path_save($path);
    }
  }
}

/**
 * Returns all the views in given modules views directory.
 */
function stools_views_from_directory_scan($module) {
  // Finds all files that match a given mask in a given directory
  // In our case, looks for any files named *.view in the /views directory.
  $files = file_scan_directory(drupal_get_path('module', $module) . '/views', '/.view/');
  foreach ($files as $filepath => $file) {
    require $filepath;
    if (isset($view)) {
      $views[$view->name] = $view;
    }
  }
  // Check that there are views in the directory
  // This keeps the site from throwing errors if there are no views to return.
  if ($views) {
    return $views;
  }
}

/**
 * Gets the delta for a views block, potentially a hash.
 */
function stools_views_block_delta($delta) {
  $views_block_delta_to_hash = array_flip(variable_get('views_block_hashes', []));
  if (isset($views_block_delta_to_hash[$delta])) {
    return $views_block_delta_to_hash[$delta];
  }
  return $delta;
}

/**
 * Rertuns list of menu items by path.
 */
function stools_get_menu_items_by_path($path, $menu_name = 'main-menu') {
  $menu_items = [];

  $path = drupal_get_normal_path($path);

  $query = db_select('menu_links', 'ml');
  $query->fields('ml');
  $query->condition('ml.menu_name', $menu_name);
  $query->condition('ml.link_path', $path);

  $results = $query->execute();

  while ($menu_item = $results->fetchAssoc()) {
    $menu_item['options'] = unserialize($menu_item['options']);
    $menu_items[] = $menu_item;
  }

  return $menu_items;

}
