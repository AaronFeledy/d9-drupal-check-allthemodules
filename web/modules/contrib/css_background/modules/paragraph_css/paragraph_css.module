<?php

/**
 * @file
 * Contains paragraph_css.module.
 */

use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Render\Element;
use Drupal\Core\Render\Markup;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\panels\Plugin\DisplayVariant\PanelsDisplayVariant;

/**
 * Implements hook_help().
 */
function paragraph_css_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the paragraph_css module.
    case 'help.page.paragraph_css':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Paragraph CSS') . '</p>';
      return $output;

    default:
  }
}

/**
 * Implements hook_entity_base_field_info().
 */
function paragraph_css_entity_base_field_info(EntityTypeInterface $entity_type) {
  $fields = [];

  // Quick exit if the entity type is not supported.
  if ($entity_type->id() != 'paragraph') {
    return $fields;
  }

  $fields['css_background'] = BaseFieldDefinition::create('entity_reference')
    ->setLabel(t('CSS background'))
    ->setDescription(t('Enter CSS backgrounds used by the paragragh. Multiple backgrounds can be specified.'))
    ->setSettings([
      'target_type' => 'css_background',
      'handler' => 'default:css_background',
      'handler_settings' => [
        'target_bundles' => NULL,
        'auto_create' => FALSE,
      ],
    ])
    ->setDisplayOptions('form', [
      'type' => 'inline_entity_form_complex',
      'weight' => 99,
      'settings' => [
        'match_operator' => 'CONTAINS',
        'form_mode' => 'default',
        'override_labels' => FALSE,
        'label_singular' => '',
        'label_plural' => '',
        'allow_new' => TRUE,
        'allow_existing' => FALSE,
      ],
    ])
    ->setDisplayConfigurable('form', TRUE);

  $fields['css_background_edgy'] = BaseFieldDefinition::create('boolean')
    ->setLabel(t('CSS background edgy'))
    ->setDescription(t('Extend background to the edge of the page.'))
    ->setDefaultValue(FALSE)
    ->setSettings([
      'on_label' => 'On',
      'off_label' => 'Off',
    ])
    ->setDisplayOptions('form', [
      'type' => 'boolean_checkbox',
      'weight' => 100,
      'settings' => [
        'display_label' => TRUE,
      ],
    ])
    ->setDisplayConfigurable('form', TRUE);

  $fields['css_text_color'] = BaseFieldDefinition::create('string')
    ->setLabel(t('CSS Text color'))
    ->setDescription(t('Enter the CSS text color. See <a href="@url">@url</a>.', [
      '@url' => 'https://www.w3schools.com/cssref/css_colors_legal.asp',
    ]))
    ->setDisplayOptions('form', [
      'type' => 'string_textfield',
      'weight' => 101,
      'settings' => [
        'size' => 60,
        'placeholder' => '',
      ],
    ])
    ->setDisplayConfigurable('form', TRUE);

  return $fields;
}

/**
 * Implements hook_panels_build_alter().
 *
 * Apply the paragraph CSS background to the panel block by walking through all
 * of the rendered blocks.
 *
 * @todo: Can this be done at the block level, instead of the layout.
 */
function paragraph_css_panels_build_alter(array &$build, PanelsDisplayVariant $panels_display) {
  // Walk each region, looking for blocks wiht paragraphs.
  $region_names = Element::children($build);
  foreach ($region_names as $region_name) {
    $css_background_strings = [];
    $css_text_color = '';
    $edgy = FALSE;
    $region_build = &$build[$region_name];
    $region_plugins = Element::children($region_build);
    foreach ($region_plugins as $plugin_id) {
      if (!isset($region_build[$plugin_id]['content']['#paragraph'])) {
        // Skip blocks without paragraphs.
        continue;
      }
      $paragraph = $region_build[$plugin_id]['content']['#paragraph'];

      // Get the CSS text color.
      if (!$css_text_color && isset($paragraph->css_text_color)) {
        $css_text_color = $paragraph->css_text_color->getValue();
      }

      // Get the CSS backgrounds.
      /** @var \Drupal\css_background\Entity\CssBackgroundEntityInterface[] $css_backgrounds */
      $css_backgrounds = [];
      if (!isset($paragraph->css_background)) {
        // Skip paragraphs without a CSS background fields.
        continue;
      }
      $css_backgrounds = $paragraph->css_background->referencedEntities();

      // Attach the background image CSS.
      if (!$css_backgrounds) {
        // Skip paragraphs with empty CSS background fields.
        continue;
      }

      // Convert the CSS background to strings.
      foreach ($css_backgrounds as $css_background) {
        $css_background_strings[] = $css_background->getCss();
      }

      // Remember the edgy setting. If edgy is set on any paragraphs in the
      // block, then it is set on all paragraphs in the block.
      if (isset($paragraph->css_background_edgy) && $paragraph->css_background_edgy->value) {
        $edgy = TRUE;
      }
    }

    // If any backgrounds were found, attach them to the region now.
    $styles = [];
    if ($css_background_strings) {
      $styles[] = 'background: ' . implode(', ', $css_background_strings);
    }
    if ($css_text_color) {
      $styles[] = 'color: ' . $css_text_color[0]['value'];
    }
    if ($styles) {
      $style = 'style="' . implode('; ', $styles) . ';"';
      $prefix = str_replace('<div', "<div $style", $region_build['#prefix']);
      if ($edgy) {
        $prefix = str_replace('class="', 'class="edgy ', $prefix);
        $region_build['#attached']['library'][] = 'paragraph_css/edgy';
      }

      // Put the prefix in a markup so that the style is not sanitized.
      $region_build['#prefix'] = Markup::create($prefix);
    }
  }
}
