<?php

/**
 * @file
 * Support module for design, markup, JavaScript, and CSS testing.
 *
 * This implementation turns every subdirectory of this module into a category
 * that is exposed as a menu link. Each subdirectory contains include files that
 * consist of a callback function that maps to the semantics of the category.
 * The following categories are supported:
 * - form: Used for Form API element tests.
 * - page: Used for theme function tests.
 *
 * For example, given an include file:
 * @code
 * ./page/list-operations.inc
 * @endcode
 * A menu router item with the path 'design_test/page/list-operations' will be
 * auto-generated. Upon access, the function design_test_page_list_operations()
 * will be called.
 *
 * The 'form' category behaves identically; e.g., for an include file
 * './form/details.inc' a menu item for the path 'design_test/form/details' is
 * created and the form constructor function design_test_form_details() will be
 * called.
 *
 * Each resulting test page is enhanced with local actions that allow to quickly
 * switch between enabled themes for verifying the expected output.
 *
 * @todo tableDrag.
 */

/**
 * Implements hook_menu_link_defaults().
 */
function design_test_menu_link_defaults() {
  $items['design_test'] = array(
    'link_title' => 'Design Test',
    'route_name' => 'design_test',
  );
  $items['design_test.form'] = array(
    'parent' => 'design_test',
    'link_title' => 'Form elements',
    'route_name' => 'design_test.category',
    'route_parameters' => array(
      'category' => 'form',
    ),
  );
  $items['design_test.page'] = array(
    'parent' => 'design_test',
    'link_title' => 'Page elements',
    'route_name' => 'design_test.category',
    'route_parameters' => array(
      'category' => 'page',
    ),
  );
  return $items;
}

/**
 * Implements hook_menu_local_tasks_alter().
 *
 * @todo D8: Local tasks do not respect additional query parameters when their
 *   "active" state is determined.
 */
function design_test_menu_local_tasks_alter(&$data, $route_name) {
  if (!preg_match('@^design_test\.\w+\.test@', $route_name)) {
    return;
  }
  $current_theme = $GLOBALS['theme'];
  foreach ($data['tabs'][0] as $tab) {
    if ($tab['#link']['route_parameters']['theme'] == $current_theme) {
      $tab['#active'] = TRUE;
      $tab['#link']['#attributes']['class'][] = 'active';
    }
  }
}


/**
 * Implements hook_help().
 */
function design_test_help($path, $arg) {
  switch ($path) {
    // Output some help text sample on the generic HTML test page.
    case 'design_test/page/html':
      return 'Page help text. ' . design_test_create_greeking(20);
  }
}

/**
 * Implements hook_element_info().
 */
function design_test_element_info() {
  // Most HTML content tests need ...
  $types['p'] = array(
    '#theme' => 'html_tag__p',
    '#tag' => 'p',
    '#pre_render' => array('design_test_pre_render_paragraph'),
    '#attributes' => array(),
    '#value' => NULL,
  );
  return $types;
}

/**
 * #pre_render callback for #type 'p'.
 */
function design_test_pre_render_paragraph($element) {
  // In case the element has any sub-elements, render them instead.
  if ($children = element_children($element)) {
    // Prepare the element properties to apply to child elements; removing the
    // children itself, as well as #type and #pre_render, so this #pre_render
    // does not get invoked recursively.
    $properties = array_diff_key($element, array_flip($children), array('#type' => 0, '#pre_render' => 0));
    foreach ($children as $key) {
      // Be smart: If it has a #value, just complete the properties.
      if (is_array($element[$key]) && isset($element[$key]['#value'])) {
        $element[$key] += $properties;
      }
      // Otherwise, build a proper sub-element.
      else {
        $element[$key] = array('#value' => $element[$key]);
        $element[$key] += $properties;
      }
    }
    unset($element['#theme']);
  }
  return $element;
}

/**
 * Stole this from Devel Generate and modified.
 */
function design_test_create_greeking($word_count, $sentences = TRUE) {
  static $dictionary = array('abbas', 'abdo', 'abico', 'abigo', 'abluo', 'accumsan',
    'acsi', 'ad', 'adipiscing', 'aliquam', 'aliquip', 'amet', 'antehabeo',
    'appellatio', 'aptent', 'at', 'augue', 'autem', 'bene', 'blandit',
    'brevitas', 'caecus', 'camur', 'capto', 'causa', 'cogo', 'comis',
    'commodo', 'commoveo', 'consectetuer', 'consequat', 'conventio', 'cui',
    'damnum', 'decet', 'defui', 'diam', 'dignissim', 'distineo', 'dolor',
    'dolore', 'dolus', 'duis', 'ea', 'eligo', 'elit', 'enim', 'erat',
    'eros', 'esca', 'esse', 'et', 'eu', 'euismod', 'eum', 'ex', 'exerci',
    'exputo', 'facilisi', 'facilisis', 'fere', 'feugiat', 'gemino',
    'genitus', 'gilvus', 'gravis', 'haero', 'hendrerit', 'hos', 'huic',
    'humo', 'iaceo', 'ibidem', 'ideo', 'ille', 'illum', 'immitto',
    'importunus', 'imputo', 'in', 'incassum', 'inhibeo', 'interdico',
    'iriure', 'iusto', 'iustum', 'jugis', 'jumentum', 'jus', 'laoreet',
    'lenis', 'letalis', 'lobortis', 'loquor', 'lucidus', 'luctus', 'ludus',
    'luptatum', 'macto', 'magna', 'mauris', 'melior', 'metuo', 'meus',
    'minim', 'modo', 'molior', 'mos', 'natu', 'neo', 'neque', 'nibh',
    'nimis', 'nisl', 'nobis', 'nostrud', 'nulla', 'nunc', 'nutus', 'obruo',
    'occuro', 'odio', 'olim', 'oppeto', 'os', 'pagus', 'pala', 'paratus',
    'patria', 'paulatim', 'pecus', 'persto', 'pertineo', 'plaga', 'pneum',
    'populus', 'praemitto', 'praesent', 'premo', 'probo', 'proprius',
    'quadrum', 'quae', 'qui', 'quia', 'quibus', 'quidem', 'quidne', 'quis',
    'ratis', 'refero', 'refoveo', 'roto', 'rusticus', 'saepius',
    'sagaciter', 'saluto', 'scisco', 'secundum', 'sed', 'si', 'similis',
    'singularis', 'sino', 'sit', 'sudo', 'suscipere', 'suscipit', 'tamen',
    'tation', 'te', 'tego', 'tincidunt', 'torqueo', 'tum', 'turpis',
    'typicus', 'ulciscor', 'ullamcorper', 'usitas', 'ut', 'utinam',
    'utrum', 'uxor', 'valde', 'valetudo', 'validus', 'vel', 'velit',
    'veniam', 'venio', 'vereor', 'vero', 'verto', 'vicis', 'vindico',
    'virtus', 'voco', 'volutpat', 'vulpes', 'vulputate', 'wisi', 'ymo',
    'zelus');

  $greeking = '';

  // Create a stack containing the requested amount of random words.
  $words = array();
  for ($i = 0; $i < $word_count; $i++) {
    $words[] = $dictionary[array_rand($dictionary)];
  }
  // If more than 10 words have been requested, build sentences.
  $chunks = array();
  if ($word_count > 10) {
    // Some variance in sentence length.
    $sentence_length = range(4, 30);
    while ($words) {
      $chunk = array_splice($words, 0, array_rand($sentence_length));
      // Only add non-empty chunks.
      if (!empty($chunk)) {
        $chunks[] = $chunk;
      }
    }
  }
  else {
    $chunks = array($words);
  }
  foreach ($chunks as $chunk) {
    $greeking .= ucfirst(implode(' ', $chunk));
    if ($sentences) {
      $greeking .= '. ';
    }
  }

  return $greeking;
}
