<?php

namespace Drupal\prepared_data\Controller;

use Drupal\Component\Utility\Unicode;
use Drupal\Core\Config\ImmutableConfig;
use Drupal\Core\DependencyInjection\ContainerInjectionInterface;
use Drupal\Core\Render\RenderContext;
use Drupal\Core\Render\RendererInterface;
use Drupal\Core\Session\AccountProxyInterface;
use Drupal\prepared_data\DataFactoryInterface;
use Drupal\prepared_data\PreparedDataInterface;
use Drupal\prepared_data\Shorthand\ShorthandsFactory;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

/**
 * Prepared Data controller class.
 */
class PreparedDataController implements ContainerInjectionInterface {

  /**
   * The factory for prepared data.
   *
   * @var \Drupal\prepared_data\DataFactoryInterface
   */
  protected $dataFactory;

  /**
   * The shorthands factory.
   *
   * @var \Drupal\prepared_data\Shorthand\ShorthandsFactory
   */
  protected $shorthands;

  /**
   * The current user.
   *
   * @var \Drupal\Core\Session\AccountProxyInterface
   */
  protected $currentUser;

  /**
   * The settings of the Prepared Data module.
   *
   * @var \Drupal\Core\Config\ImmutableConfig
   */
  protected $settings;

  /**
   * The Drupal renderer.
   *
   * @var \Drupal\Core\Render\RendererInterface
   */
  protected $renderer;

  /**
   * {@inheritdoc}
   */
  public static function create(ContainerInterface $container) {
    $data_factory = $container->get('prepared_data.factory');
    $shorthands = $container->get('prepared_data.shorthands');
    $config_factory = $container->get('config.factory');
    $current_user = $container->get('current_user');
    $settings = $config_factory->get('prepared_data.settings');
    $renderer = $container->get('renderer');
    return new static($data_factory, $shorthands, $current_user, $settings, $renderer);
  }

  /**
   * PreparedDataController constructor.
   *
   * @param \Drupal\prepared_data\DataFactoryInterface $data_factory
   *   The factory for prepared data.
   * @param \Drupal\prepared_data\Shorthand\ShorthandsFactory
   *   The shorthands factory.
   * @param \Drupal\Core\Session\AccountProxyInterface $current_user
   *   The current user.
   * @param \Drupal\Core\Config\ImmutableConfig $settings
   *   The settings of the Prepared Data module.
   * @param \Drupal\Core\Render\RendererInterface $renderer
   *   The Drupal renderer.
   */
  public function __construct(DataFactoryInterface $data_factory, ShorthandsFactory $shorthands, AccountProxyInterface $current_user, ImmutableConfig $settings, RendererInterface $renderer) {
    $this->dataFactory = $data_factory;
    $this->shorthands = $shorthands;
    $this->currentUser = $current_user;
    $this->settings = $settings;
    $this->renderer = $renderer;
  }

  /**
   * Returns a JSON response containing requested prepared data.
   *
   * @param \Symfony\Component\HttpFoundation\Request $request
   *   The request object.
   *
   * @return \Symfony\Component\HttpFoundation\JsonResponse
   *   A JSON response on success.
   *
   * @throws \Symfony\Component\HttpKernel\Exception\NotFoundHttpException
   *   In case the requested data is not available.
   */
  public function get(Request $request) {
    if ($id = $request->query->get('s')) {
      if ($shorthand = $this->shorthands->get($id)) {
        $key = $shorthand->key();
        $subset_keys = $shorthand->subsetKeys();
      }
    }
    else {
      $key = $request->query->get('k');
      if (empty($subset_keys = $request->query->get('sk'))) {
        $subset_keys = [];
      }
    }
    if (empty($key)) {
      throw new NotFoundHttpException();
    }
    $data_factory = $this->dataFactory;
    $current_user = $this->currentUser;

    // When building or refreshing data, processors might render something.
    // Any metadata generated by these renderings will be ignored here,
    // because prepared data does not depend on any bubbleable metadata.
    $data = $this->renderer->executeInRenderContext(new RenderContext(), function () use ($data_factory, $key, $current_user) {
      return $data_factory->get($key, FALSE, FALSE, $current_user);
    });
    if (!isset($data)) {
      throw new NotFoundHttpException();
    }

    // Drupal's Page Cache does not respect cache contexts.
    // @todo Use CacheableJsonResponse and corresponding headers once
    //  https://www.drupal.org/project/drupal/issues/2972483 is solved.
    // $response = new CacheableJsonResponse();
    // $response->getCacheableMetadata()->addCacheContexts(['headers:Origin', 'headers:AMP-Same-Origin']);
    $response = new JsonResponse();
    $response->setJson($data->encode($subset_keys));
    $this->setCORSHeaders($request, $response);
    $this->setCacheHeaders($response, $data);

    return $response;
  }

  /**
   * Sets proper CORS headers based on the given request.
   *
   * @param \Symfony\Component\HttpFoundation\Request $request
   *   The current request.
   * @param \Symfony\Component\HttpFoundation\Response $response
   *   The corresponding response.
   */
  protected function setCORSHeaders(Request $request, Response $response) {
    $response->setVary('Origin', FALSE);
    $host = $request->getSchemeAndHttpHost();
    $origin = $request->headers->get('Origin');

    // Support CORS for cached Accelerated Mobile Pages (AMP).
    if ($request->query->has('__amp_source_origin')) {
      $response->setVary('AMP-Same-Origin', FALSE);
      $source_origin = $request->query->get('__amp_source_origin');
      if (($source_origin !== $host) || !Unicode::validateUtf8($source_origin)) {
        return;
      }
      if ('true' === $request->headers->get('AMP-Same-Origin')) {
        $origin = $source_origin;
      }
    }

    if (empty($origin) || !Unicode::validateUtf8($origin)) {
      return;
    }

    $is_allowed = FALSE;
    $cors_allowed = $this->settings->get('cors_allowed');
    $cors_allowed[] = $host;
    foreach ($cors_allowed as $whitelisted) {
      if ($origin === $whitelisted) {
        $is_allowed = TRUE;
        break;
      }
      elseif (strpos($whitelisted, '*') === 0) {
        $whitelisted = str_replace('*', '', $whitelisted);
        if ('' === $whitelisted) {
          $is_allowed = TRUE;
          $origin = '*';
          break;
        }
        elseif (strpos($origin, $whitelisted) !== FALSE) {
          $rest = str_replace($whitelisted, '', $origin);
          // Ensure to allow only for subdomains.
          if (empty($rest) || (strpos($origin, $rest) === 0)) {
            $is_allowed = TRUE;
            break;
          }
        }
      }
    }
    if (!$is_allowed) {
      return;
    }

    // Set headers to allow cross-origin resource sharing.
    $response->headers->set('Access-Control-Allow-Origin', $origin);
    $response->headers->set('Access-Control-Allow-Credentials', 'true');
    if (!empty($source_origin)) {
      $response->headers->set('Access-Control-Expose-Headers', 'AMP-Access-Control-Allow-Source-Origin');
      $response->headers->set('AMP-Access-Control-Allow-Source-Origin', $source_origin);
    }
  }

  /**
   * Sets cacheability headers at the given response.
   *
   * @param \Symfony\Component\HttpFoundation\Response $response
   *   The response to handle.
   * @param \Drupal\prepared_data\PreparedDataInterface $data
   *   The object which wraps prepared data.
   */
  protected function setCacheHeaders(Response $response, PreparedDataInterface $data) {
    $settings = $this->settings;
    $s_maxage = (int) $settings->get('s_maxage');
    $max_age = (int) $settings->get('max_age');
    $no_cache = empty($s_maxage) && empty($max_age);
    $current_user = $this->currentUser;

    if ($no_cache || !$current_user->isAnonymous() || $current_user->isAuthenticated()) {
      $response->setPrivate();
      $response->setLastModified(NULL);
      $response->setVary(NULL);
      $response->headers->addCacheControlDirective('must-revalidate');
      $response->headers->addCacheControlDirective('no-cache');
      return;
    }

    $response->setPublic();
    $expires = (new \DateTime())->setTimezone(new \DateTimeZone('UTC'))->setTimestamp($data->expires());
    $expires_timeline = $data->expires() - time();
    if ($expires_timeline > 300) {
      if ($s_maxage > ($expires_timeline / 2)) {
        $s_maxage = (int) ($expires_timeline / 2);
      }
      if ($max_age > ($expires_timeline / 20)) {
        $max_age = (int) ($expires_timeline / 20);
      }
    }
    else {
      // Despite the data is expired, set some minimal caching
      // to prevent an overflow of direct backend requests.
      if ($s_maxage > 300) {
        $s_maxage = 300;
      }
      if ($max_age > 60) {
        $max_age = 60;
      }
      $expires->setTimestamp(time() + $s_maxage);
    }
    $response->setExpires($expires);
    $response->setSharedMaxAge($s_maxage);
    $response->setMaxAge($max_age);
  }

}
