<?php

/**
 * @file
 * Contains concurrent_edit_notify.module.
 */

use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\node\NodeInterface;

/**
 * Implements hook_help().
 */
function concurrent_edit_notify_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the concurrent_edit_notify module.
    case 'help.page.concurrent_edit_notify':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Notify users if an author is already editing a node.') . '</p>';
      $output .= '<h3>' . t('Implementation') . '</h3>';
      $output .= '<p>' . t('At interval an ajax request is made while editing a moderated node to check if the current revision is outdated. If so, a message is printed before the form and the save button so the editor can take any action before saving and overriding any change.') . '</p>';
      $output .= '<p>' . t('If the concurrent revision is saved in a published state, a Drupal constraint will bring an error when saving the form, this module just alert before saving for this.<br>If the concurrent revision is not moved in a published state, the current revision will replace any changes made on the concurrent one. This is where this module bring a message to alert the editor for this use case.') . '</p>';
      return $output;

    default:
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node entities.
 */
function concurrent_edit_notify_form_node_form_alter(&$form, FormStateInterface &$form_state, $form_id) {
  // Alter only node edit forms.
  if (strpos($form_id, '_edit_form') !== FALSE) {
    $token = [];
    $node = $form_state->getFormObject()->getEntity();
    if (($node instanceof NodeInterface) && ($node->isTranslatable())) {
      $concurrent_token = Drupal::service('concurrent_edit_notify.concurrent_token');
      // Get parameter values.
      $token['uid'] = \Drupal::currentUser()->id();
      $token['langcode'] = $node->get('langcode')->value;
      $token['nid'] = $node->id();
      // Create token only for valid inputs.
      if (!empty($token['uid']) && !empty($token['nid']) && !empty($token['langcode'])) {
        $token['status'] = 0;
        // Save token.
        $concurrent_token->save($token);
        // Check if we are on a moderated content.
        $moderation_info = Drupal::service('content_moderation.moderation_information');
        if ($moderation_info->isModeratedEntity($node)) {
          // When coming back from preview, getRevisionId is empty.
          $vid = $node->getRevisionId();
          if ($vid == NULL) {
            $vid = $node->getLoadedRevisionId();
          }
          // Log in case of error.
          if ($vid == NULL) {
            $message = 'Missing version for node: @nid';
            \Drupal::logger('concurrent_edit_notify')->error($message, ['@nid' => $node->id()]);
          }
          else {
            $first_token = $concurrent_token->loadFirst($node->id(), $node->get('langcode')->value);
            $first_user = \Drupal::entityTypeManager()->getStorage('user')->load($first_token->uid);
            if (!$concurrent_token->isAccountLoggedIn($first_user)) {
              concurrent_edit_notify_delete_tokens_by_node($node);
              return;
            }
            // Add our scripts for ajax request.
            $config = \Drupal::config('concurrent_edit_notify.settings');
            $form['#attached']['library'][] = 'concurrent_edit_notify/concurrent-edit-notify';
            $form['#attached']['drupalSettings']['concurrent_edit_notify'] = [
              'interval' => $config->get('interval') * 1000,
              $token['uid'] => [
                'node' => [
                  'nid' => $node->id(),
                  'vid' => $vid,
                ],
              ],
              'first_uid' => $first_token->uid,
            ];
          }
        }
      }
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 */
function concurrent_edit_notify_node_presave(NodeInterface $node) {
  if ($node->isTranslatable()) {
    concurrent_edit_notify_delete_tokens_by_node($node);
  }
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 */
function concurrent_edit_notify_node_delete(NodeInterface $node) {
  if ($node->isTranslatable()) {
    concurrent_edit_notify_delete_tokens_by_node($node);
  }
}

/**
 * Implements hook_ENTITY_TYPE_translation_delete().
 */
function concurrent_edit_notify_node_translation_delete(NodeInterface $node) {
  if ($node->isTranslatable()) {
    concurrent_edit_notify_delete_tokens_by_node($node);
  }
}

/**
 * Wrapper to delete concurrent tokens.
 *
 * @param \Drupal\node\NodeInterface $node
 *   The node object.
 */
function concurrent_edit_notify_delete_tokens_by_node(NodeInterface $node) {
  $concurrent_token = Drupal::service('concurrent_edit_notify.concurrent_token');
  $langcode = $node->get('langcode')->value;
  $concurrent_token->delete($node->id(), $langcode);
}
