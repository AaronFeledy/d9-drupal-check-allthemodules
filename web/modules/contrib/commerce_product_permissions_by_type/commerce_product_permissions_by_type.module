<?php

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Cache\CacheableMetadata;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Render\Element;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Url;
use Drupal\user\Entity\Role;
use Drupal\user\RoleInterface;

/**
 * Implements hook_form_BASE_FORM_ID_alter() for
 * commerce_order_item_add_to_cart_form.
 */
function commerce_product_permissions_by_type_form_commerce_order_item_add_to_cart_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $storage = $form_state->getStorage();
  if (isset($storage['product'])) {
    /** @var \Drupal\commerce_product\Entity\ProductInterface $product */
    $product = $storage['product'];
    $permission = 'add ' . $product->bundle() . ' commerce_product to cart';
    $current_user = \Drupal::currentUser();

    if (!$current_user->hasPermission($permission)) {
      // Hide all the form elements.
      foreach (Element::children($form) as $key) {
        $form[$key]['#access'] = FALSE;
      }

      // Show either a login link or an explanation for the missing add to cart
      // form elements.
      if ($current_user->isAnonymous() && Role::load(RoleInterface::AUTHENTICATED_ID)->hasPermission($permission)) {
        // The user could buy the product if they logged in.
        $destination = ['destination' => $product->url('canonical')];
        $form['login'] = [
          '#type' => 'link',
          '#title' => t('Log in to buy this product'),
          '#url' => Url::fromRoute('user.login', [], ['query' => $destination]),
        ];
      }
      else {
        // Either the user is logged in and does not have the permission to buy,
        // or they are logged out but we don't know that logging in would get
        // them anywhere.
        $form['access_denied'] = [
          '#markup' => t('You do not have the necessary rights to buy this product'),
        ];
      }
    }

    // This form's cacheability may have been changed as it is now based
    // on the current user and permissions.
    $cacheable_metadata = (new CacheableMetadata())
      ->addCacheContexts(['user.permissions']);
    $cacheable_metadata->applyTo($form);
  }
}

/**
 * Implements hook_ENTITY_TYPE_access() for 'commerce_product' entities.
 *
 * Drupal\entity\EntityAccessControlHandler::checkEntityPermissions doesn't
 * check for per-bundle permissions if $operation is 'view', so do that here.
 */
function commerce_product_permissions_by_type_commerce_product_access(EntityInterface $entity, $operation, AccountInterface $account) {
  if ($operation === 'view') {
    $permission = "view {$entity->bundle()} {$entity->getEntityTypeId()}";
    return AccessResult::allowedIfHasPermission($account, $permission);
  }
  return AccessResult::neutral();
}
