<?php

use Drupal\Core\Routing\RouteMatchInterface;

/**
 * Implements hook_help().
 */
function timelogin_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'help.page.timelogin':
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t("By using this module, administor can restrict role based user to login with given time slots by the administrator.") . '</p>';
      $output .= '<dd>' . t('Site admin can set the time slots for the user roles from <a href=":add-time-slots">here</a>.', array(':add-time-slots' => \Drupal::url('timelogin.manage_timeslot'))) . '</dd>';
      return $output;
  }
}

/**
 * 
 * @param string $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param type $form_id
 */
function timelogin_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {

  switch ($form_id) {
    case 'user_login_form':
      $form['#validate'][] = 'timelogin_validate';
      break;
  }
}

/**
 * 
 * @param type $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function timelogin_validate(&$form, \Drupal\Core\Form\FormStateInterface $form_state) {

  $name = $form_state->getValue('name');
  if ($name) {
    $query = db_select('users_field_data', 'u');
    $query->fields('u', array('uid'))
      ->condition('u.name', db_like($name), 'LIKE')
      ->condition('u.status', 1);
    $uid = $query->execute()->fetchAll();

    if (count($uid) > 0) {
      // Check if username exists in user table.
      $query = db_select('user__roles', 'ur');
      $query->fields('ur', array('roles_target_id'))
        ->condition('ur.entity_id', $uid[0]->uid);
      $roles = $query->execute()->fetchAll();
      $role_name = $roles[0]->roles_target_id;
      $all_roles_rid = array();
      $rolesArray = \Drupal\user\Entity\Role::loadMultiple();
      $roles = array_keys($rolesArray);
      if (in_array($role_name, $roles)) {
        $rid = array_search($role_name, $roles);
        $all_roles_rid[] = $rid;
      }
      if (!empty($all_roles_rid)) {
        timelogin_roles_check($all_roles_rid);
      }
    }
  }
}

/**
 * Function to get the rolese of the current user.
 *
 * @return bool
 *   Return ture if user can log in.
 */
function timelogin_user_access() {
  $userCurrent = \Drupal::currentUser();
  $user = Drupal\user\Entity\User::load($userCurrent->id());
  $roles = $user->getRoles();
  foreach ($roles as $rid => $role_name) {
    $rolesArray = \Drupal\user\Entity\Role::loadMultiple();
    $roles = array_keys($rolesArray);
    if (in_array($role_name, $roles)) {
      $rid = array_search($role_name, $roles);
      $all_roles[] = $rid;
    }
  }
  return timelogin_roles_check($all_roles);
}

/**
 * Function to check if user can log in or not.
 *
 * Superadmin can login anytime.
 *
 * @param array $all_roles
 *   Array containing all the roles of User.
 *
 * @return bool
 *   Return ture if user can log in.
 */

function timelogin_roles_check($all_roles) {
  $query = db_select('time_login', 'tl')
    ->fields('tl', array('timelogin_from_time', 'timelogin_to_time'))
    ->condition('tl.timelogin_role_id', $all_roles, 'IN');
  $time_slots = $query->execute()->fetchAll();
  $current_time = array();
  $current_time['hrs'] = date('H') == '00' ? 0 : date('H');
  $current_time['min'] = date('i') == '00' ? 0 : date('i');
  if (count($time_slots) > 0 && !empty($time_slots) && !in_array(2, $all_roles)) {
    foreach ($time_slots as $time_slot) {
      $from_time = $time_slot->timelogin_from_time;
      $to_time = $time_slot->timelogin_to_time;
      //Logout user if condition execute.
      if (timelogin_check_time_from($current_time, $from_time) && timelogin_check_time_to($current_time, $to_time)) {
        drupal_set_message(t('You are not authorised to access the site in this time slot.'));
        user_logout();
      }
      else {
        return;
      }
    }
  }
  else {
    return;
  }
}

/**
 * Function to check the user login from time.
 *
 * @param array $current_time
 *   Contains hours and minutes of current time.
 * @param string $from_time
 *   Contains from time the user can login.
 *
 * @return bool
 *   Returns if current time is greater than from time.
 */

function timelogin_check_time_from($current_time, $from_time) {
  $afrom_time = explode(':', $from_time);
  $afrom_time[0] = $afrom_time[0] == '00' ? 0 : $afrom_time[0];
  $afrom_time[1] = $afrom_time[1] == '00' ? 0 : $afrom_time[1];
  if ($current_time['hrs'] >= $afrom_time[0]) {
    if ($current_time['hrs'] == $afrom_time[0] && $current_time['min'] <= $afrom_time[1]) {
      return FALSE;
    }
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Function to check the user login to time.
 *
 * @param array $current_time
 *   Contains hours and minutes of current time.
 * @param string $to_time
 *   Contains to time the user can login.
 *
 * @return bool
 *   Returns if current time is less than to time.
 */
function timelogin_check_time_to($current_time, $to_time) {
  $ato_time = explode(':', $to_time);
  $ato_time[0] = $ato_time[0] == '00' ? 0 : $ato_time[0];
  $ato_time[1] = $ato_time[1] == '00' ? 0 : $ato_time[1];
  if ($current_time['hrs'] <= $ato_time[0]) {
    if ($current_time['hrs'] == $ato_time[0] && $current_time['min'] >= $ato_time[1]) {
      return FALSE;
    }
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * 
 * @param type $to_time_flag
 * @return string
 */
function timelogin_timeslot_generator($to_time_flag = 0) {
  $total_slots = array();
  $minutes = array('00', '15', '30', '45');
  for ($hours = 0; $hours < 24; $hours++) {
    foreach ($minutes as $value) {
      if ($hours < 10) {
        $total_slots['0' . $hours . ':' . $value] = '0' . $hours . ':' . $value;
      }
      else {
        $total_slots[$hours . ':' . $value] = $hours . ':' . $value;
      }
    }
  }
  if ($to_time_flag) {
    // Removing the first option and adding the last option.
    unset($total_slots['00:00']);
    $total_slots['24:00'] = '24:00';
  }
  return $total_slots;
}

/**
 * Function to delete time slot.
 *
 * @param int $tlid
 *   Time slot id to be deleted.
 */
function timelogin_timeslot_delete($tlid) {
  db_delete('time_login')
    ->condition('id', $tlid)
    ->execute();
}
