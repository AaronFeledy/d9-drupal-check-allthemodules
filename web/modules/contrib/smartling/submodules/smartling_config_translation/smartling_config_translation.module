<?php

use Drupal\views\ViewExecutable;
use Drupal\views\Plugin\views\PluginBase;
use Drupal\views\Plugin\views\query\Sql as QueryPluginBase;
use Drupal\config_translation\ConfigEntityMapper;
use Drupal\config_translation\ConfigFieldMapper;
use Drupal\Core\Config\Entity\ConfigEntityTypeInterface;
/**
 * Implements hook_entity_type_alter().
 */
function smartling_config_translation_entity_type_alter(array &$entity_types) {

  //@todo: reimplement this part, for dinamically generated config list
  $config_list = ['block', 'block_content_type', 'comment_type', 'contact_form', 'filter_format',
    'image_style', 'configurable_language', 'node_type', 'search_page', 'shortcut_set', 'menu', 'taxonomy_vocabulary',
    'user_role', 'view', 'date_format', 'entity_form_mode', 'entity_view_mode'];

  foreach ($entity_types as $entity_type) {
    if (in_array($entity_type->id(), $config_list)) {
    //if (($entity_type instanceof ConfigEntityTypeInterface)  && $entity_type->isTranslatable()) {
      if (!$entity_type->hasHandlerClass('smartling')) {
        $entity_type->setHandlerClass('smartling', '\Drupal\smartling\SmartlingEntityHandler');
      }
    }
  }
  return;
//  static $depth = 0;
//
//  //@todo: implement a better fix for the infinite recursion that is happening here.
//  if ($depth > 0) {
//    return;
//  }
//  $depth++;
//
//  $mprs = \Drupal::getContainer()->get('plugin.manager.config_translation.mapper')->getMappers();
//  $mappers = array_filter($mprs, function($mapper) {
//    return ($mapper instanceof ConfigEntityMapper
//      && ! $mapper instanceof ConfigFieldMapper
//     );
//  });
//
//  if (empty($mappers)) {
//    return;
//  }
//  $bundles = array_keys($mappers);
//
//  var_dump($bundles);die();
//  // Provide defaults for translation info.
//  /** @var $entity_types \Drupal\Core\Entity\EntityTypeInterface[] */
//  foreach ($entity_types as $entity_type) {
//    if (in_array($entity_type->id(), $bundles) &&  (!$entity_type->hasHandlerClass('smartling'))) {
//      //var_dump($entity_type->id());
//      $entity_type->setHandlerClass('smartling', '\Drupal\smartling\SmartlingEntityHandler');
//    }
//  }
  //die();
}


function smartling_config_translation_views_data_alter(array &$data) {
  //$tbl = $data['smartling_config_translation'];
  //print_r(array_keys($tbl));
  //die();

  $data['smartling_config_translation']['dummy_name'] = array(
    'title' => t('Title seen while adding relationship'),
    'help' => t('More information about the relationship'),

    'relationship' => array(
      // Views name of the table being joined to from foo.
      'base' => 'smartling_submission',
      // Database field name in example_table for the join.
      'base field' => 'entity_id',
      // Real database field name in foo for the join, to override
      // 'unique_dummy_name'.
      'field' => 'name',
      // ID of relationship handler plugin to use.
      'id' => 'standard',
      'label' => t('Default label for relationship'),
    ),
  );


  $data['smartling_config_translation']['target_language'] = [
    'title' => t('Target Language'),
    'field' => [
      //'real field' => 'target_language',
      'id' => 'smartling_submission_config_target_language',
      'title' => t('Target Language'),
      'help' => t('Smartling submission "target_language" property.'),
      //'click sortable' => TRUE,

    ],
  ];
}



//function smartling_config_translation_views_query_alter(ViewExecutable $view, QueryPluginBase $query) {
//  // (Example assuming a view with an exposed filter on node title.)
//  // If the input for the title filter is a positive integer, filter against
//  // node ID instead of node title.
//  if ($view->id() == 'smartling_configs_translation') {
//    // Traverse through the 'where' part of the query.
//    foreach ($query->where as &$condition_group) {
//      foreach ($condition_group['conditions'] as &$condition) {
//        // If this is the part of the query filtering on title, chang the
//        // condition to filter on node ID.
//        if ($condition['field'] == 'node.title') {
//          $condition = array(
//            'field' => 'node.nid',
//            'value' => $view->exposed_raw_input['title'],
//            'operator' => '=',
//          );
//        }
//      }
//    }
//  }
//}